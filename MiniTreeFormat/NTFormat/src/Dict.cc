//
// File generated by /opt/exp_soft/cms/slc5_amd64_gcc434/lcg/root/5.27.06b-cms23//bin/rootcint at Thu Apr 11 20:18:27 2013

// Do NOT change. Changes will be lost next time file is generated
//

#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "Dict.h"

#include "TCollectionProxyInfo.h"
#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"

// START OF SHADOWS

namespace ROOT {
   namespace Shadow {
      namespace TopTree {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TopTree::NTLepton NTLepton;
      #else
      class NTLepton  {
         public:
         //friend XX;
         ::TLorentzVector p4; //
         ::TLorentzVector p4HLT; //
         ::TVector3 vertex; //
         double Charge; //
         double TrkIso03; //summed track pt in a cone of deltaR<0.3
         double ECaloIso03; //ecal iso deposit from RecHits with electron footprint removed (cone = 0.3)
         double HCaloIso03; //hcal iso deposit from calo Towers (cone = 0.3)
         double CaloIso03; //sum of ECaloIso and HCaloIso
         double PATNeutralHadronIso; //
         double PATChargedHadronIso; //
         double PATPhotonIso; //
         double PATTrackIso; //
         float D0; //Transverse IP
         float Chi2; //Normalized chi2 
         int LeptonOrigin; //
         double turnOnWeight; //
      };
      #endif
      } 
      namespace TopTree {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TopTree::NTElectron NTElectron;
      #else
      class NTElectron  :  public ::TopTree::NTLepton {
         public:
         //friend XX;
         bool isGsfElectron; //* correspond to elec->ecalDrivenSeed () in PAT */
         float ET_SC; //* ET of the SuperCluster */
         int nLost; //
         int elecIdLoose; //
         int elecIdTight; //
         int elecIdRobustLoose; //
         int elecIdRobustTight; //
         int elecIdWP90_c; //* Working Point 90, combined iso (simple cut based ID) */ 
         int elecIdWP90_r; //* Working Point 90, relative iso (simple cut based ID) */
         int cicVeryLoose; //
         int cicLoose; //
         int cicMedium; //
         int cicTight; //
         int cicSuperTight; //
         int cicHyperTight1; //
         int cicHyperTight2; //
         int cicHyperTight3; //
         int cicVeryLooseMC; //
         int cicLooseMC; //
         int cicMediumMC; //
         int cicTightMC; //
         int cicSuperTightMC; //
         int cicHyperTight1MC; //
         int cicHyperTight2MC; //
         int cicHyperTight3MC; //
         int isEB; //isEE * 1 + isEB * 10
         bool isEcalDriven; //
         float elspike; //
         double eSuperClusterOverP; //
         double fbrem; //
         int nlost; //
         float deltaCotTheta; //
         float deltaDistance; //
      };
      #endif
      } 
      namespace TopTree {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TopTree::NTJet NTJet;
      #else
      class NTJet  {
         public:
         //friend XX;
         ::TLorentzVector p4; //* 4 vector of jet.*/
         ::TLorentzVector p4Gen; //* 4 vector of gen jet.*/
         ::TLorentzVector p4Parton; //* 4 vector of gen jet.*/
         ::TLorentzVector p4HLT; //* 4 vector of matched HLT jet.*/
         double emEnergyFraction; //* jet electromagnetic energy fraction  // ( not defined for pfjet)  */
         double hadEnergyFraction; //* jet hadronic energy fraction */
         double CHEF; //* Charged Hadronic Energy Fraction */  
         double CEEF; //* Charged Electromagnetic Energy Fraction  (for Pf jet ID) */
         double NHEF; //* Neutral Hadronic Energy Fraction  */
         double NEEF; //* Neutral Electromagnetic Energy Fraction */  
         double n90Hits; //* Number of recHits (i.e. cells) needed to make up 90% of the jet's energy 
         double fHPD; //* fraction of jet energy from the highest energy Hybrid Photo Diode (not for pfjet) */
         bool passJetID; //
         int partonFlavour; //
         vector< pair< ::string, float >  > DiscriPair; //* dump of PAT content for all the taggers */
         double TCDiscri; //* b-tagging discriminator for TrackCounting algorithm */
         double SVDiscri; //* b-tagging discriminator for SecondaryVertex algorithm */
         double SMDiscri; //* b-tagging discriminator for SM algorithm */
         int nTracks; //* number of tracks associated to the jet */
         int sumPtTracks; //* the scalar sum of Pt of the nTracks tracks */ 
         int nTracksSVX; //* number of tracks from SV tagger (== IP tagger) */
         int nSVX; //* number of Secondary Vertices */
         double chi2SVX; //* chi2 of the best secondary vertex */
         double ndofSVX; //* ndof of the best secondary vertex */
         double flightDistanceSVX; //* distance (3D)  between primary and best secondary vertex */
         double flightDistanceSigSVX; //* distance significance (3D) between primary and secondary vertex */
         double flightDistanceErrSVX; //* distance error (3D) between primary and secondary vertex */
         double MassSVX; //* inv. mass of the best secondary vertex */
         double turnOnWeight; //
         double corrJES; //
      };
      #endif
      } 
      namespace TopTree {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TopTree::NTPhoton NTPhoton;
      #else
      class NTPhoton  {
         public:
         //friend XX;
         ::TLorentzVector p4; //
         double TrkIso; //summed track pt in a cone of deltaR<0.4
         double ECaloIso; //ecal iso deposit from RecHits with electron footprint removed (cone = 0.4)
         double HCaloIso; //hcal iso deposit from calo Towers (cone = 0.4)
         bool isEB; //
         float e1x5; //
         float e2x5; //
         float e3x3; //
         float e5x5; //
      };
      #endif
      } 
      namespace TopTree {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TopTree::NTMuon NTMuon;
      #else
      class NTMuon  :  public ::TopTree::NTLepton {
         public:
         //friend XX;
         int MuonType; //* IsGlobalMuon * 100 + IsStandAloneMuon * 10 + IsTrackerMuon * 1; */
         int GlobalMuonPromptTight; //
         int NTrValidHits; //* nof valid hits associated to the tracker track */
         int NValidHits; //* nof valid hits associated to the global track */
         float D0Inner; //Transverse IP from tracks
         int NOfMatches; //
      };
      #endif
      } 
      namespace TopTree {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TopTree::NTTau NTTau;
      #else
      class NTTau  :  public ::TopTree::NTLepton {
         public:
         //friend XX;
         double leadTrackPt; //
         double numSigConeTracks; //
         double numIsoConeTracks; //
         int decay; //
         float isolationPFChargedHadrCandsPtSum; //
         float isolationPFGammaCandsEtSum; //
         float maximumHCALPFClusterEt; //
         float emFraction; //
         float hcalTotOverPLead; //
         float hcalMaxOverPLead; //
         float hcal3x3OverPLead; //
         float ecalStripSumEOverPLead; //
         int decayMode; //
         vector< pair< ::string, float >  > tauIDs; //
      };
      #endif
      } 
      namespace TopTree {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TopTree::NTMET NTMET;
      #else
      class NTMET  {
         public:
         //friend XX;
         ::TLorentzVector p4; //* missing Et vector -->> 4D vector since no 2D object available in [root/5.14.00f-CMS3q] ... */
         double correction; //
         double turnOnWeight; //
      };
      #endif
      } 
      namespace TopTree {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TopTree::NTJetMet NTJetMet;
      #else
      class NTJetMet  :  public ::TopTree::NTCollection< ::TopTree::NTJet > {
         public:
         //friend XX;
         ::TopTree::NTMET met; //
         double sumEtJet; //
         double sumEtJetRaw; //
      };
      #endif
      } 
      namespace TopTree {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TopTree::NTCollection< ::TopTree::NTJet > NTCollectionlETopTreecLcLNTJetgR;
      #else
      class NTCollectionlETopTreecLcLNTJetgR  {
         public:
         //friend XX;
         vector< ::TopTree::NTJet > objects; //object = TopTree::NTJet or TopTree::NTTau...
         string algo; //
      };
      #endif
      } 
      namespace TopTree {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TopTree::NTVertex NTVertex;
      #else
      class NTVertex  {
         public:
         //friend XX;
         ::TVector3 p3; //*X-Y-Z coordinates */
         double chi2; //
         int isFake; //
         int isValid; //
         double ndof; //
         double rho; //
         double normalizedChi2; //
         int NumberOfTracks; //
      };
      #endif
      } 
      namespace TopTree {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TopTree::NTTrack NTTrack;
      #else
      class NTTrack  {
         public:
         //friend XX;
         ::TLorentzVector p4; //
         int charge; //
         double Chi2; //
         double d0; //
         double d0Error; //
         double dxy; //
         double dxy_BS; //
         double dxyError; //
         double dz; //
         double dzError; //
      };
      #endif
      } 
      namespace TopTree {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TopTree::WDecaysMC WDecaysMC;
      #else
      class WDecaysMC  {
         public:
         //friend XX;
         double Q_Lep_gen; //
         ::TLorentzVector p4_W_gen; //
         ::TLorentzVector p4_Lep_gen; //
         ::TLorentzVector p4_Neu_gen; //
         ::TLorentzVector p4_SumTauNeu_gen; //
         int Tmeme; //
         int mcLepId; //
      };
      #endif
      } 
      namespace TopTree {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TopTree::ZDecaysMC ZDecaysMC;
      #else
      class ZDecaysMC  {
         public:
         //friend XX;
         ::TLorentzVector p4_Z_gen; //
         ::TLorentzVector p4_Lep1_gen; //
         ::TLorentzVector p4_Lep2_gen; //
         ::TLorentzVector p4_SumTauNeu_gen; //
         ::TLorentzVector p4_SumTauANeu_gen; //
         double Q_Lep1_gen; //
         double Q_Lep2_gen; //
         int Lep1_pdgID; //
         int Lep2_pdgID; //
         int Tmeme; //
         int Zgtobb; //
      };
      #endif
      } 
      namespace TopTree {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TopTree::TopDecaysMC TopDecaysMC;
      #else
      class TopDecaysMC  {
         public:
         //friend XX;
         double Q_gen; //
         ::TLorentzVector p4_b_gen; //
         ::TLorentzVector p4_t_gen; //
         int mcLepId; //
      };
      #endif
      } 
      namespace TopTree {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TopTree::NTPU NTPU;
      #else
      class NTPU  {
         public:
         //friend XX;
         int bunchCrossing; //to which bunch crossing does this interaction belong?  
         float zpositions; //the true primary vertex position along the z axis for each added interaction
         float sumpT_lowpT; //the sum of the transverse momentum of the tracks originating from each interaction, where track pT > low_cut
         float sumpT_highpT; //the sum of the transverse momentum of the tracks originating from each interaction, where track pT > high_cut
         int ntrks_lowpT; //the number of tracks originating from each interaction, where track pT > low_cut
         int ntrks_highpT; //the number of tracks originating from each interaction, where track pT > high_cut
      };
      #endif
      } 
      namespace TopTree {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TopTree::NTEvent NTEvent;
      #else
      class NTEvent  {
         public:
         //friend XX;
         unsigned int runNb; //
         unsigned int eventNb; //
         double eventWeight; //
         int lumiblock; //
         int procId; //
         string eventType; //
         int TMEME; //*
         int ptHat; //
         pair< int, int > pdgIdPartons; //* pdgId of the initial partons */
         vector< pair< ::string, bool >  > triggers; //
         float match_HLT_Ele10_LW_L1R_recoEl; //
         vector< pair< ::string, int >  > prescales; //
         vector< ::TLorentzVector > tauObjTrig; //
         vector< ::TLorentzVector > jetObjTrig; //
         vector< NTVertex > VertexVec; //
         ::TVector3 p3BS; //
         ::TVector3 p3BSErr; //
         double rho_PUUE_dens; //
         double neutralRho_PUUE_dens; //
         int num_pileup_bc0; //the number of pileup interactions of Bunch Crossing  0, that have been added to the event
         int num_pileup_bcp1; //the number of pileup interactions of Bunch Crossing p1, that have been added to the event
         int num_pileup_bcm1; //the number of pileup interactions of Bunch Crossing m1, that have been added to the event
         vector< NTPU > pileup; //dedicated PU information
         vector< NTJetMet > jetMetVec; //
         vector< NTElectron > electrons; //
         vector< NTMuon > muons; //
         vector< ::TopTree::NTCollection< NTTau >  > tausVec; //
         vector< NTPhoton > photons; //
         vector< NTTrack > tracks; //
         vector< ::TLorentzVector > Generatedtaus; //
         vector< ::TLorentzVector > GeneratedAtaus; //
         vector< ::TLorentzVector > genBquarks; //
         vector< ::TLorentzVector > genCquarks; //
         vector< ::TLorentzVector > genLquarks; //
         vector< ::TLorentzVector > genGquarks; //
         vector< WDecaysMC > wAndDecays; //
         vector< ZDecaysMC > zAndDecays; //
         vector< TopDecaysMC > topAndDecays; //
         vector< vector< ::TLorentzVector, allocator< ::TLorentzVector >  >  > GeneratedtausLepPlusDecays; //
         vector< vector< ::TLorentzVector, allocator< ::TLorentzVector >  >  > GeneratedtausLepMinusDecays; //
         vector< vector< ::TLorentzVector, allocator< ::TLorentzVector >  >  > GeneratedtausPionPlusDecays; //
         vector< vector< ::TLorentzVector, allocator< ::TLorentzVector >  >  > GeneratedtausPionMinusDecays; //
         vector< WDecaysMC > wPlusAndDecays; //
         vector< WDecaysMC > wMinusAndDecays; //
         vector< TopDecaysMC > topPlusAndDecays; //
         vector< TopDecaysMC > topMinusAndDecays; //
         vector< float > pdfWeights; //
         int partonFlavor1; //
         int partonFlavor2; //
         float x1; //
         float x2; //
         float Q_scale; //
      };
      #endif
      } 
      namespace TopTree {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TopTree::NTCollection< ::TopTree::NTTau > NTCollectionlETopTreecLcLNTTaugR;
      #else
      class NTCollectionlETopTreecLcLNTTaugR  {
         public:
         //friend XX;
         vector< ::TopTree::NTTau > objects; //object = TopTree::NTJet or TopTree::NTTau...
         string algo; //
      };
      #endif
      } 
      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< ::string, bool > pairlEstringcOboolgR;
      #else
      class pairlEstringcOboolgR  {
         public:
         //friend XX;
         string first; //
         bool second; //
      };
      #endif

   } // of namespace Shadow
} // of namespace ROOT
// END OF SHADOWS

namespace ROOT {
   void TopTreecLcLNTLepton_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TopTreecLcLNTLepton_Dictionary();
   static void *new_TopTreecLcLNTLepton(void *p = 0);
   static void *newArray_TopTreecLcLNTLepton(Long_t size, void *p);
   static void delete_TopTreecLcLNTLepton(void *p);
   static void deleteArray_TopTreecLcLNTLepton(void *p);
   static void destruct_TopTreecLcLNTLepton(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TopTree::NTLepton*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TopTree::NTLepton) == sizeof(::ROOT::Shadow::TopTree::NTLepton));
      ::TopTree::NTLepton *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TopTree::NTLepton),0);
      static ::ROOT::TGenericClassInfo 
         instance("TopTree::NTLepton", "./../interface/NTLepton.h", 20,
                  typeid(::TopTree::NTLepton), DefineBehavior(ptr, ptr),
                  &TopTreecLcLNTLepton_ShowMembers, &TopTreecLcLNTLepton_Dictionary, isa_proxy, 4,
                  sizeof(::TopTree::NTLepton) );
      instance.SetNew(&new_TopTreecLcLNTLepton);
      instance.SetNewArray(&newArray_TopTreecLcLNTLepton);
      instance.SetDelete(&delete_TopTreecLcLNTLepton);
      instance.SetDeleteArray(&deleteArray_TopTreecLcLNTLepton);
      instance.SetDestructor(&destruct_TopTreecLcLNTLepton);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TopTree::NTLepton*)
   {
      return GenerateInitInstanceLocal((::TopTree::NTLepton*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TopTree::NTLepton*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TopTreecLcLNTLepton_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTLepton*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TopTreecLcLNTElectron_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TopTreecLcLNTElectron_Dictionary();
   static void *new_TopTreecLcLNTElectron(void *p = 0);
   static void *newArray_TopTreecLcLNTElectron(Long_t size, void *p);
   static void delete_TopTreecLcLNTElectron(void *p);
   static void deleteArray_TopTreecLcLNTElectron(void *p);
   static void destruct_TopTreecLcLNTElectron(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TopTree::NTElectron*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TopTree::NTElectron) == sizeof(::ROOT::Shadow::TopTree::NTElectron));
      ::TopTree::NTElectron *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TopTree::NTElectron),0);
      static ::ROOT::TGenericClassInfo 
         instance("TopTree::NTElectron", "./../interface/NTElectron.h", 17,
                  typeid(::TopTree::NTElectron), DefineBehavior(ptr, ptr),
                  &TopTreecLcLNTElectron_ShowMembers, &TopTreecLcLNTElectron_Dictionary, isa_proxy, 4,
                  sizeof(::TopTree::NTElectron) );
      instance.SetNew(&new_TopTreecLcLNTElectron);
      instance.SetNewArray(&newArray_TopTreecLcLNTElectron);
      instance.SetDelete(&delete_TopTreecLcLNTElectron);
      instance.SetDeleteArray(&deleteArray_TopTreecLcLNTElectron);
      instance.SetDestructor(&destruct_TopTreecLcLNTElectron);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TopTree::NTElectron*)
   {
      return GenerateInitInstanceLocal((::TopTree::NTElectron*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TopTree::NTElectron*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TopTreecLcLNTElectron_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTElectron*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TopTreecLcLNTJet_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TopTreecLcLNTJet_Dictionary();
   static void *new_TopTreecLcLNTJet(void *p = 0);
   static void *newArray_TopTreecLcLNTJet(Long_t size, void *p);
   static void delete_TopTreecLcLNTJet(void *p);
   static void deleteArray_TopTreecLcLNTJet(void *p);
   static void destruct_TopTreecLcLNTJet(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TopTree::NTJet*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TopTree::NTJet) == sizeof(::ROOT::Shadow::TopTree::NTJet));
      ::TopTree::NTJet *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TopTree::NTJet),0);
      static ::ROOT::TGenericClassInfo 
         instance("TopTree::NTJet", "./../interface/NTJet.h", 16,
                  typeid(::TopTree::NTJet), DefineBehavior(ptr, ptr),
                  &TopTreecLcLNTJet_ShowMembers, &TopTreecLcLNTJet_Dictionary, isa_proxy, 4,
                  sizeof(::TopTree::NTJet) );
      instance.SetNew(&new_TopTreecLcLNTJet);
      instance.SetNewArray(&newArray_TopTreecLcLNTJet);
      instance.SetDelete(&delete_TopTreecLcLNTJet);
      instance.SetDeleteArray(&deleteArray_TopTreecLcLNTJet);
      instance.SetDestructor(&destruct_TopTreecLcLNTJet);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TopTree::NTJet*)
   {
      return GenerateInitInstanceLocal((::TopTree::NTJet*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TopTree::NTJet*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TopTreecLcLNTJet_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTJet*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TopTreecLcLNTPhoton_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TopTreecLcLNTPhoton_Dictionary();
   static void *new_TopTreecLcLNTPhoton(void *p = 0);
   static void *newArray_TopTreecLcLNTPhoton(Long_t size, void *p);
   static void delete_TopTreecLcLNTPhoton(void *p);
   static void deleteArray_TopTreecLcLNTPhoton(void *p);
   static void destruct_TopTreecLcLNTPhoton(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TopTree::NTPhoton*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TopTree::NTPhoton) == sizeof(::ROOT::Shadow::TopTree::NTPhoton));
      ::TopTree::NTPhoton *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TopTree::NTPhoton),0);
      static ::ROOT::TGenericClassInfo 
         instance("TopTree::NTPhoton", "./../interface/NTPhoton.h", 20,
                  typeid(::TopTree::NTPhoton), DefineBehavior(ptr, ptr),
                  &TopTreecLcLNTPhoton_ShowMembers, &TopTreecLcLNTPhoton_Dictionary, isa_proxy, 4,
                  sizeof(::TopTree::NTPhoton) );
      instance.SetNew(&new_TopTreecLcLNTPhoton);
      instance.SetNewArray(&newArray_TopTreecLcLNTPhoton);
      instance.SetDelete(&delete_TopTreecLcLNTPhoton);
      instance.SetDeleteArray(&deleteArray_TopTreecLcLNTPhoton);
      instance.SetDestructor(&destruct_TopTreecLcLNTPhoton);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TopTree::NTPhoton*)
   {
      return GenerateInitInstanceLocal((::TopTree::NTPhoton*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TopTree::NTPhoton*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TopTreecLcLNTPhoton_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTPhoton*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TopTreecLcLNTMuon_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TopTreecLcLNTMuon_Dictionary();
   static void *new_TopTreecLcLNTMuon(void *p = 0);
   static void *newArray_TopTreecLcLNTMuon(Long_t size, void *p);
   static void delete_TopTreecLcLNTMuon(void *p);
   static void deleteArray_TopTreecLcLNTMuon(void *p);
   static void destruct_TopTreecLcLNTMuon(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TopTree::NTMuon*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TopTree::NTMuon) == sizeof(::ROOT::Shadow::TopTree::NTMuon));
      ::TopTree::NTMuon *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TopTree::NTMuon),0);
      static ::ROOT::TGenericClassInfo 
         instance("TopTree::NTMuon", "./../interface/NTMuon.h", 17,
                  typeid(::TopTree::NTMuon), DefineBehavior(ptr, ptr),
                  &TopTreecLcLNTMuon_ShowMembers, &TopTreecLcLNTMuon_Dictionary, isa_proxy, 4,
                  sizeof(::TopTree::NTMuon) );
      instance.SetNew(&new_TopTreecLcLNTMuon);
      instance.SetNewArray(&newArray_TopTreecLcLNTMuon);
      instance.SetDelete(&delete_TopTreecLcLNTMuon);
      instance.SetDeleteArray(&deleteArray_TopTreecLcLNTMuon);
      instance.SetDestructor(&destruct_TopTreecLcLNTMuon);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TopTree::NTMuon*)
   {
      return GenerateInitInstanceLocal((::TopTree::NTMuon*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TopTree::NTMuon*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TopTreecLcLNTMuon_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTMuon*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TopTreecLcLNTTau_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TopTreecLcLNTTau_Dictionary();
   static void *new_TopTreecLcLNTTau(void *p = 0);
   static void *newArray_TopTreecLcLNTTau(Long_t size, void *p);
   static void delete_TopTreecLcLNTTau(void *p);
   static void deleteArray_TopTreecLcLNTTau(void *p);
   static void destruct_TopTreecLcLNTTau(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TopTree::NTTau*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TopTree::NTTau) == sizeof(::ROOT::Shadow::TopTree::NTTau));
      ::TopTree::NTTau *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TopTree::NTTau),0);
      static ::ROOT::TGenericClassInfo 
         instance("TopTree::NTTau", "./../interface/NTTau.h", 12,
                  typeid(::TopTree::NTTau), DefineBehavior(ptr, ptr),
                  &TopTreecLcLNTTau_ShowMembers, &TopTreecLcLNTTau_Dictionary, isa_proxy, 4,
                  sizeof(::TopTree::NTTau) );
      instance.SetNew(&new_TopTreecLcLNTTau);
      instance.SetNewArray(&newArray_TopTreecLcLNTTau);
      instance.SetDelete(&delete_TopTreecLcLNTTau);
      instance.SetDeleteArray(&deleteArray_TopTreecLcLNTTau);
      instance.SetDestructor(&destruct_TopTreecLcLNTTau);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TopTree::NTTau*)
   {
      return GenerateInitInstanceLocal((::TopTree::NTTau*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TopTree::NTTau*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TopTreecLcLNTTau_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTTau*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TopTreecLcLNTMET_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TopTreecLcLNTMET_Dictionary();
   static void *new_TopTreecLcLNTMET(void *p = 0);
   static void *newArray_TopTreecLcLNTMET(Long_t size, void *p);
   static void delete_TopTreecLcLNTMET(void *p);
   static void deleteArray_TopTreecLcLNTMET(void *p);
   static void destruct_TopTreecLcLNTMET(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TopTree::NTMET*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TopTree::NTMET) == sizeof(::ROOT::Shadow::TopTree::NTMET));
      ::TopTree::NTMET *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TopTree::NTMET),0);
      static ::ROOT::TGenericClassInfo 
         instance("TopTree::NTMET", "./../interface/NTMET.h", 16,
                  typeid(::TopTree::NTMET), DefineBehavior(ptr, ptr),
                  &TopTreecLcLNTMET_ShowMembers, &TopTreecLcLNTMET_Dictionary, isa_proxy, 4,
                  sizeof(::TopTree::NTMET) );
      instance.SetNew(&new_TopTreecLcLNTMET);
      instance.SetNewArray(&newArray_TopTreecLcLNTMET);
      instance.SetDelete(&delete_TopTreecLcLNTMET);
      instance.SetDeleteArray(&deleteArray_TopTreecLcLNTMET);
      instance.SetDestructor(&destruct_TopTreecLcLNTMET);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TopTree::NTMET*)
   {
      return GenerateInitInstanceLocal((::TopTree::NTMET*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TopTree::NTMET*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TopTreecLcLNTMET_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTMET*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TopTreecLcLNTJetMet_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TopTreecLcLNTJetMet_Dictionary();
   static void *new_TopTreecLcLNTJetMet(void *p = 0);
   static void *newArray_TopTreecLcLNTJetMet(Long_t size, void *p);
   static void delete_TopTreecLcLNTJetMet(void *p);
   static void deleteArray_TopTreecLcLNTJetMet(void *p);
   static void destruct_TopTreecLcLNTJetMet(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TopTree::NTJetMet*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TopTree::NTJetMet) == sizeof(::ROOT::Shadow::TopTree::NTJetMet));
      ::TopTree::NTJetMet *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TopTree::NTJetMet),0);
      static ::ROOT::TGenericClassInfo 
         instance("TopTree::NTJetMet", "./../interface/NTJetMet.h", 17,
                  typeid(::TopTree::NTJetMet), DefineBehavior(ptr, ptr),
                  &TopTreecLcLNTJetMet_ShowMembers, &TopTreecLcLNTJetMet_Dictionary, isa_proxy, 4,
                  sizeof(::TopTree::NTJetMet) );
      instance.SetNew(&new_TopTreecLcLNTJetMet);
      instance.SetNewArray(&newArray_TopTreecLcLNTJetMet);
      instance.SetDelete(&delete_TopTreecLcLNTJetMet);
      instance.SetDeleteArray(&deleteArray_TopTreecLcLNTJetMet);
      instance.SetDestructor(&destruct_TopTreecLcLNTJetMet);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TopTree::NTJetMet*)
   {
      return GenerateInitInstanceLocal((::TopTree::NTJetMet*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TopTree::NTJetMet*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TopTreecLcLNTJetMet_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTJetMet*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TopTreecLcLNTCollectionlETopTreecLcLNTJetgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TopTreecLcLNTCollectionlETopTreecLcLNTJetgR_Dictionary();
   static void *new_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR(void *p = 0);
   static void *newArray_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR(Long_t size, void *p);
   static void delete_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR(void *p);
   static void deleteArray_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR(void *p);
   static void destruct_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TopTree::NTCollection<TopTree::NTJet>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TopTree::NTCollection<TopTree::NTJet>) == sizeof(::ROOT::Shadow::TopTree::NTCollectionlETopTreecLcLNTJetgR));
      ::TopTree::NTCollection<TopTree::NTJet> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TopTree::NTCollection<TopTree::NTJet>),0);
      static ::ROOT::TGenericClassInfo 
         instance("TopTree::NTCollection<TopTree::NTJet>", "./../interface/NTCollection.h", 17,
                  typeid(::TopTree::NTCollection<TopTree::NTJet>), DefineBehavior(ptr, ptr),
                  &TopTreecLcLNTCollectionlETopTreecLcLNTJetgR_ShowMembers, &TopTreecLcLNTCollectionlETopTreecLcLNTJetgR_Dictionary, isa_proxy, 4,
                  sizeof(::TopTree::NTCollection<TopTree::NTJet>) );
      instance.SetNew(&new_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR);
      instance.SetNewArray(&newArray_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR);
      instance.SetDelete(&delete_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR);
      instance.SetDeleteArray(&deleteArray_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR);
      instance.SetDestructor(&destruct_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TopTree::NTCollection<TopTree::NTJet>*)
   {
      return GenerateInitInstanceLocal((::TopTree::NTCollection<TopTree::NTJet>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TopTree::NTCollection<TopTree::NTJet>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TopTreecLcLNTCollectionlETopTreecLcLNTJetgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTCollection<TopTree::NTJet>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TopTreecLcLNTVertex_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TopTreecLcLNTVertex_Dictionary();
   static void *new_TopTreecLcLNTVertex(void *p = 0);
   static void *newArray_TopTreecLcLNTVertex(Long_t size, void *p);
   static void delete_TopTreecLcLNTVertex(void *p);
   static void deleteArray_TopTreecLcLNTVertex(void *p);
   static void destruct_TopTreecLcLNTVertex(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TopTree::NTVertex*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TopTree::NTVertex) == sizeof(::ROOT::Shadow::TopTree::NTVertex));
      ::TopTree::NTVertex *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TopTree::NTVertex),0);
      static ::ROOT::TGenericClassInfo 
         instance("TopTree::NTVertex", "./../interface/NTVertex.h", 16,
                  typeid(::TopTree::NTVertex), DefineBehavior(ptr, ptr),
                  &TopTreecLcLNTVertex_ShowMembers, &TopTreecLcLNTVertex_Dictionary, isa_proxy, 4,
                  sizeof(::TopTree::NTVertex) );
      instance.SetNew(&new_TopTreecLcLNTVertex);
      instance.SetNewArray(&newArray_TopTreecLcLNTVertex);
      instance.SetDelete(&delete_TopTreecLcLNTVertex);
      instance.SetDeleteArray(&deleteArray_TopTreecLcLNTVertex);
      instance.SetDestructor(&destruct_TopTreecLcLNTVertex);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TopTree::NTVertex*)
   {
      return GenerateInitInstanceLocal((::TopTree::NTVertex*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TopTree::NTVertex*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TopTreecLcLNTVertex_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTVertex*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TopTreecLcLNTTrack_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TopTreecLcLNTTrack_Dictionary();
   static void *new_TopTreecLcLNTTrack(void *p = 0);
   static void *newArray_TopTreecLcLNTTrack(Long_t size, void *p);
   static void delete_TopTreecLcLNTTrack(void *p);
   static void deleteArray_TopTreecLcLNTTrack(void *p);
   static void destruct_TopTreecLcLNTTrack(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TopTree::NTTrack*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TopTree::NTTrack) == sizeof(::ROOT::Shadow::TopTree::NTTrack));
      ::TopTree::NTTrack *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TopTree::NTTrack),0);
      static ::ROOT::TGenericClassInfo 
         instance("TopTree::NTTrack", "./../interface/NTTrack.h", 15,
                  typeid(::TopTree::NTTrack), DefineBehavior(ptr, ptr),
                  &TopTreecLcLNTTrack_ShowMembers, &TopTreecLcLNTTrack_Dictionary, isa_proxy, 4,
                  sizeof(::TopTree::NTTrack) );
      instance.SetNew(&new_TopTreecLcLNTTrack);
      instance.SetNewArray(&newArray_TopTreecLcLNTTrack);
      instance.SetDelete(&delete_TopTreecLcLNTTrack);
      instance.SetDeleteArray(&deleteArray_TopTreecLcLNTTrack);
      instance.SetDestructor(&destruct_TopTreecLcLNTTrack);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TopTree::NTTrack*)
   {
      return GenerateInitInstanceLocal((::TopTree::NTTrack*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TopTree::NTTrack*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TopTreecLcLNTTrack_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTTrack*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TopTreecLcLWDecaysMC_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TopTreecLcLWDecaysMC_Dictionary();
   static void *new_TopTreecLcLWDecaysMC(void *p = 0);
   static void *newArray_TopTreecLcLWDecaysMC(Long_t size, void *p);
   static void delete_TopTreecLcLWDecaysMC(void *p);
   static void deleteArray_TopTreecLcLWDecaysMC(void *p);
   static void destruct_TopTreecLcLWDecaysMC(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TopTree::WDecaysMC*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TopTree::WDecaysMC) == sizeof(::ROOT::Shadow::TopTree::WDecaysMC));
      ::TopTree::WDecaysMC *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TopTree::WDecaysMC),0);
      static ::ROOT::TGenericClassInfo 
         instance("TopTree::WDecaysMC", "./../interface/WDecaysMC.h", 13,
                  typeid(::TopTree::WDecaysMC), DefineBehavior(ptr, ptr),
                  &TopTreecLcLWDecaysMC_ShowMembers, &TopTreecLcLWDecaysMC_Dictionary, isa_proxy, 4,
                  sizeof(::TopTree::WDecaysMC) );
      instance.SetNew(&new_TopTreecLcLWDecaysMC);
      instance.SetNewArray(&newArray_TopTreecLcLWDecaysMC);
      instance.SetDelete(&delete_TopTreecLcLWDecaysMC);
      instance.SetDeleteArray(&deleteArray_TopTreecLcLWDecaysMC);
      instance.SetDestructor(&destruct_TopTreecLcLWDecaysMC);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TopTree::WDecaysMC*)
   {
      return GenerateInitInstanceLocal((::TopTree::WDecaysMC*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TopTree::WDecaysMC*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TopTreecLcLWDecaysMC_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TopTree::WDecaysMC*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TopTreecLcLZDecaysMC_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TopTreecLcLZDecaysMC_Dictionary();
   static void *new_TopTreecLcLZDecaysMC(void *p = 0);
   static void *newArray_TopTreecLcLZDecaysMC(Long_t size, void *p);
   static void delete_TopTreecLcLZDecaysMC(void *p);
   static void deleteArray_TopTreecLcLZDecaysMC(void *p);
   static void destruct_TopTreecLcLZDecaysMC(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TopTree::ZDecaysMC*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TopTree::ZDecaysMC) == sizeof(::ROOT::Shadow::TopTree::ZDecaysMC));
      ::TopTree::ZDecaysMC *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TopTree::ZDecaysMC),0);
      static ::ROOT::TGenericClassInfo 
         instance("TopTree::ZDecaysMC", "./../interface/ZDecaysMC.h", 13,
                  typeid(::TopTree::ZDecaysMC), DefineBehavior(ptr, ptr),
                  &TopTreecLcLZDecaysMC_ShowMembers, &TopTreecLcLZDecaysMC_Dictionary, isa_proxy, 4,
                  sizeof(::TopTree::ZDecaysMC) );
      instance.SetNew(&new_TopTreecLcLZDecaysMC);
      instance.SetNewArray(&newArray_TopTreecLcLZDecaysMC);
      instance.SetDelete(&delete_TopTreecLcLZDecaysMC);
      instance.SetDeleteArray(&deleteArray_TopTreecLcLZDecaysMC);
      instance.SetDestructor(&destruct_TopTreecLcLZDecaysMC);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TopTree::ZDecaysMC*)
   {
      return GenerateInitInstanceLocal((::TopTree::ZDecaysMC*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TopTree::ZDecaysMC*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TopTreecLcLZDecaysMC_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TopTree::ZDecaysMC*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TopTreecLcLTopDecaysMC_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TopTreecLcLTopDecaysMC_Dictionary();
   static void *new_TopTreecLcLTopDecaysMC(void *p = 0);
   static void *newArray_TopTreecLcLTopDecaysMC(Long_t size, void *p);
   static void delete_TopTreecLcLTopDecaysMC(void *p);
   static void deleteArray_TopTreecLcLTopDecaysMC(void *p);
   static void destruct_TopTreecLcLTopDecaysMC(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TopTree::TopDecaysMC*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TopTree::TopDecaysMC) == sizeof(::ROOT::Shadow::TopTree::TopDecaysMC));
      ::TopTree::TopDecaysMC *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TopTree::TopDecaysMC),0);
      static ::ROOT::TGenericClassInfo 
         instance("TopTree::TopDecaysMC", "./../interface/topDecaysMC.h", 13,
                  typeid(::TopTree::TopDecaysMC), DefineBehavior(ptr, ptr),
                  &TopTreecLcLTopDecaysMC_ShowMembers, &TopTreecLcLTopDecaysMC_Dictionary, isa_proxy, 4,
                  sizeof(::TopTree::TopDecaysMC) );
      instance.SetNew(&new_TopTreecLcLTopDecaysMC);
      instance.SetNewArray(&newArray_TopTreecLcLTopDecaysMC);
      instance.SetDelete(&delete_TopTreecLcLTopDecaysMC);
      instance.SetDeleteArray(&deleteArray_TopTreecLcLTopDecaysMC);
      instance.SetDestructor(&destruct_TopTreecLcLTopDecaysMC);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TopTree::TopDecaysMC*)
   {
      return GenerateInitInstanceLocal((::TopTree::TopDecaysMC*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TopTree::TopDecaysMC*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TopTreecLcLTopDecaysMC_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TopTree::TopDecaysMC*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TopTreecLcLNTPU_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TopTreecLcLNTPU_Dictionary();
   static void *new_TopTreecLcLNTPU(void *p = 0);
   static void *newArray_TopTreecLcLNTPU(Long_t size, void *p);
   static void delete_TopTreecLcLNTPU(void *p);
   static void deleteArray_TopTreecLcLNTPU(void *p);
   static void destruct_TopTreecLcLNTPU(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TopTree::NTPU*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TopTree::NTPU) == sizeof(::ROOT::Shadow::TopTree::NTPU));
      ::TopTree::NTPU *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TopTree::NTPU),0);
      static ::ROOT::TGenericClassInfo 
         instance("TopTree::NTPU", "./../interface/NTPU.h", 16,
                  typeid(::TopTree::NTPU), DefineBehavior(ptr, ptr),
                  &TopTreecLcLNTPU_ShowMembers, &TopTreecLcLNTPU_Dictionary, isa_proxy, 4,
                  sizeof(::TopTree::NTPU) );
      instance.SetNew(&new_TopTreecLcLNTPU);
      instance.SetNewArray(&newArray_TopTreecLcLNTPU);
      instance.SetDelete(&delete_TopTreecLcLNTPU);
      instance.SetDeleteArray(&deleteArray_TopTreecLcLNTPU);
      instance.SetDestructor(&destruct_TopTreecLcLNTPU);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TopTree::NTPU*)
   {
      return GenerateInitInstanceLocal((::TopTree::NTPU*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TopTree::NTPU*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TopTreecLcLNTPU_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTPU*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TopTreecLcLNTEvent_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TopTreecLcLNTEvent_Dictionary();
   static void *new_TopTreecLcLNTEvent(void *p = 0);
   static void *newArray_TopTreecLcLNTEvent(Long_t size, void *p);
   static void delete_TopTreecLcLNTEvent(void *p);
   static void deleteArray_TopTreecLcLNTEvent(void *p);
   static void destruct_TopTreecLcLNTEvent(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TopTree::NTEvent*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TopTree::NTEvent) == sizeof(::ROOT::Shadow::TopTree::NTEvent));
      ::TopTree::NTEvent *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TopTree::NTEvent),0);
      static ::ROOT::TGenericClassInfo 
         instance("TopTree::NTEvent", "./../interface/NTEvent.h", 36,
                  typeid(::TopTree::NTEvent), DefineBehavior(ptr, ptr),
                  &TopTreecLcLNTEvent_ShowMembers, &TopTreecLcLNTEvent_Dictionary, isa_proxy, 4,
                  sizeof(::TopTree::NTEvent) );
      instance.SetNew(&new_TopTreecLcLNTEvent);
      instance.SetNewArray(&newArray_TopTreecLcLNTEvent);
      instance.SetDelete(&delete_TopTreecLcLNTEvent);
      instance.SetDeleteArray(&deleteArray_TopTreecLcLNTEvent);
      instance.SetDestructor(&destruct_TopTreecLcLNTEvent);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TopTree::NTEvent*)
   {
      return GenerateInitInstanceLocal((::TopTree::NTEvent*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TopTree::NTEvent*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TopTreecLcLNTEvent_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTEvent*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TopTreecLcLNTCollectionlETopTreecLcLNTTaugR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TopTreecLcLNTCollectionlETopTreecLcLNTTaugR_Dictionary();
   static void *new_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR(void *p = 0);
   static void *newArray_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR(Long_t size, void *p);
   static void delete_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR(void *p);
   static void deleteArray_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR(void *p);
   static void destruct_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TopTree::NTCollection<TopTree::NTTau>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TopTree::NTCollection<TopTree::NTTau>) == sizeof(::ROOT::Shadow::TopTree::NTCollectionlETopTreecLcLNTTaugR));
      ::TopTree::NTCollection<TopTree::NTTau> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TopTree::NTCollection<TopTree::NTTau>),0);
      static ::ROOT::TGenericClassInfo 
         instance("TopTree::NTCollection<TopTree::NTTau>", "./../interface/NTCollection.h", 17,
                  typeid(::TopTree::NTCollection<TopTree::NTTau>), DefineBehavior(ptr, ptr),
                  &TopTreecLcLNTCollectionlETopTreecLcLNTTaugR_ShowMembers, &TopTreecLcLNTCollectionlETopTreecLcLNTTaugR_Dictionary, isa_proxy, 4,
                  sizeof(::TopTree::NTCollection<TopTree::NTTau>) );
      instance.SetNew(&new_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR);
      instance.SetNewArray(&newArray_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR);
      instance.SetDelete(&delete_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR);
      instance.SetDeleteArray(&deleteArray_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR);
      instance.SetDestructor(&destruct_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TopTree::NTCollection<TopTree::NTTau>*)
   {
      return GenerateInitInstanceLocal((::TopTree::NTCollection<TopTree::NTTau>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TopTree::NTCollection<TopTree::NTTau>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TopTreecLcLNTCollectionlETopTreecLcLNTTaugR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTCollection<TopTree::NTTau>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEstringcOboolgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void pairlEstringcOboolgR_Dictionary();
   static void *new_pairlEstringcOboolgR(void *p = 0);
   static void *newArray_pairlEstringcOboolgR(Long_t size, void *p);
   static void delete_pairlEstringcOboolgR(void *p);
   static void deleteArray_pairlEstringcOboolgR(void *p);
   static void destruct_pairlEstringcOboolgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<string,bool>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<string,bool> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<string,bool>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<string,bool>", "prec_stl/utility", 17,
                  typeid(pair<string,bool>), DefineBehavior(ptr, ptr),
                  &pairlEstringcOboolgR_ShowMembers, &pairlEstringcOboolgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<string,bool>) );
      instance.SetNew(&new_pairlEstringcOboolgR);
      instance.SetNewArray(&newArray_pairlEstringcOboolgR);
      instance.SetDelete(&delete_pairlEstringcOboolgR);
      instance.SetDeleteArray(&deleteArray_pairlEstringcOboolgR);
      instance.SetDestructor(&destruct_pairlEstringcOboolgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<string,bool>*)
   {
      return GenerateInitInstanceLocal((pair<string,bool>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<string,bool>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEstringcOboolgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<string,bool>*)0x0)->GetClass();
   }

} // end of namespace ROOT

//______________________________________________________________________________
namespace ROOT {
   void TopTreecLcLNTLepton_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class TopTree::NTLepton.
      typedef ::ROOT::Shadow::TopTree::NTLepton ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTLepton*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p4", &sobj->p4);
      R__insp.InspectMember(sobj->p4, "p4.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p4HLT", &sobj->p4HLT);
      R__insp.InspectMember(sobj->p4HLT, "p4HLT.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "vertex", &sobj->vertex);
      R__insp.InspectMember(sobj->vertex, "vertex.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Charge", &sobj->Charge);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TrkIso03", &sobj->TrkIso03);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ECaloIso03", &sobj->ECaloIso03);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "HCaloIso03", &sobj->HCaloIso03);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "CaloIso03", &sobj->CaloIso03);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PATNeutralHadronIso", &sobj->PATNeutralHadronIso);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PATChargedHadronIso", &sobj->PATChargedHadronIso);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PATPhotonIso", &sobj->PATPhotonIso);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PATTrackIso", &sobj->PATTrackIso);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "D0", &sobj->D0);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Chi2", &sobj->Chi2);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "LeptonOrigin", &sobj->LeptonOrigin);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "turnOnWeight", &sobj->turnOnWeight);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TopTreecLcLNTLepton(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTLepton : new ::TopTree::NTLepton;
   }
   static void *newArray_TopTreecLcLNTLepton(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTLepton[nElements] : new ::TopTree::NTLepton[nElements];
   }
   // Wrapper around operator delete
   static void delete_TopTreecLcLNTLepton(void *p) {
      delete ((::TopTree::NTLepton*)p);
   }
   static void deleteArray_TopTreecLcLNTLepton(void *p) {
      delete [] ((::TopTree::NTLepton*)p);
   }
   static void destruct_TopTreecLcLNTLepton(void *p) {
      typedef ::TopTree::NTLepton current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TopTree::NTLepton

//______________________________________________________________________________
namespace ROOT {
   void TopTreecLcLNTMuon_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class TopTree::NTMuon.
      typedef ::ROOT::Shadow::TopTree::NTMuon ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTMuon*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "MuonType", &sobj->MuonType);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "GlobalMuonPromptTight", &sobj->GlobalMuonPromptTight);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NTrValidHits", &sobj->NTrValidHits);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NValidHits", &sobj->NValidHits);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "D0Inner", &sobj->D0Inner);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NOfMatches", &sobj->NOfMatches);
      R__insp.GenericShowMembers("TopTree::NTLepton", ( ::TopTree::NTLepton * )( (::TopTree::NTMuon*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TopTreecLcLNTMuon(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTMuon : new ::TopTree::NTMuon;
   }
   static void *newArray_TopTreecLcLNTMuon(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTMuon[nElements] : new ::TopTree::NTMuon[nElements];
   }
   // Wrapper around operator delete
   static void delete_TopTreecLcLNTMuon(void *p) {
      delete ((::TopTree::NTMuon*)p);
   }
   static void deleteArray_TopTreecLcLNTMuon(void *p) {
      delete [] ((::TopTree::NTMuon*)p);
   }
   static void destruct_TopTreecLcLNTMuon(void *p) {
      typedef ::TopTree::NTMuon current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TopTree::NTMuon

//______________________________________________________________________________
namespace ROOT {
   void TopTreecLcLNTElectron_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class TopTree::NTElectron.
      typedef ::ROOT::Shadow::TopTree::NTElectron ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTElectron*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "isGsfElectron", &sobj->isGsfElectron);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ET_SC", &sobj->ET_SC);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nLost", &sobj->nLost);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "elecIdLoose", &sobj->elecIdLoose);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "elecIdTight", &sobj->elecIdTight);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "elecIdRobustLoose", &sobj->elecIdRobustLoose);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "elecIdRobustTight", &sobj->elecIdRobustTight);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "elecIdWP90_c", &sobj->elecIdWP90_c);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "elecIdWP90_r", &sobj->elecIdWP90_r);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "cicVeryLoose", &sobj->cicVeryLoose);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "cicLoose", &sobj->cicLoose);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "cicMedium", &sobj->cicMedium);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "cicTight", &sobj->cicTight);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "cicSuperTight", &sobj->cicSuperTight);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "cicHyperTight1", &sobj->cicHyperTight1);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "cicHyperTight2", &sobj->cicHyperTight2);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "cicHyperTight3", &sobj->cicHyperTight3);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "cicVeryLooseMC", &sobj->cicVeryLooseMC);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "cicLooseMC", &sobj->cicLooseMC);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "cicMediumMC", &sobj->cicMediumMC);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "cicTightMC", &sobj->cicTightMC);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "cicSuperTightMC", &sobj->cicSuperTightMC);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "cicHyperTight1MC", &sobj->cicHyperTight1MC);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "cicHyperTight2MC", &sobj->cicHyperTight2MC);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "cicHyperTight3MC", &sobj->cicHyperTight3MC);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "isEB", &sobj->isEB);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "isEcalDriven", &sobj->isEcalDriven);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "elspike", &sobj->elspike);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "eSuperClusterOverP", &sobj->eSuperClusterOverP);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fbrem", &sobj->fbrem);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nlost", &sobj->nlost);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "deltaCotTheta", &sobj->deltaCotTheta);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "deltaDistance", &sobj->deltaDistance);
      R__insp.GenericShowMembers("TopTree::NTLepton", ( ::TopTree::NTLepton * )( (::TopTree::NTElectron*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TopTreecLcLNTElectron(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTElectron : new ::TopTree::NTElectron;
   }
   static void *newArray_TopTreecLcLNTElectron(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTElectron[nElements] : new ::TopTree::NTElectron[nElements];
   }
   // Wrapper around operator delete
   static void delete_TopTreecLcLNTElectron(void *p) {
      delete ((::TopTree::NTElectron*)p);
   }
   static void deleteArray_TopTreecLcLNTElectron(void *p) {
      delete [] ((::TopTree::NTElectron*)p);
   }
   static void destruct_TopTreecLcLNTElectron(void *p) {
      typedef ::TopTree::NTElectron current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TopTree::NTElectron

//______________________________________________________________________________
namespace ROOT {
   void TopTreecLcLNTPhoton_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class TopTree::NTPhoton.
      typedef ::ROOT::Shadow::TopTree::NTPhoton ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTPhoton*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p4", &sobj->p4);
      R__insp.InspectMember(sobj->p4, "p4.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TrkIso", &sobj->TrkIso);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ECaloIso", &sobj->ECaloIso);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "HCaloIso", &sobj->HCaloIso);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "isEB", &sobj->isEB);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "e1x5", &sobj->e1x5);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "e2x5", &sobj->e2x5);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "e3x3", &sobj->e3x3);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "e5x5", &sobj->e5x5);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TopTreecLcLNTPhoton(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTPhoton : new ::TopTree::NTPhoton;
   }
   static void *newArray_TopTreecLcLNTPhoton(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTPhoton[nElements] : new ::TopTree::NTPhoton[nElements];
   }
   // Wrapper around operator delete
   static void delete_TopTreecLcLNTPhoton(void *p) {
      delete ((::TopTree::NTPhoton*)p);
   }
   static void deleteArray_TopTreecLcLNTPhoton(void *p) {
      delete [] ((::TopTree::NTPhoton*)p);
   }
   static void destruct_TopTreecLcLNTPhoton(void *p) {
      typedef ::TopTree::NTPhoton current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TopTree::NTPhoton

//______________________________________________________________________________
namespace ROOT {
   void TopTreecLcLNTTau_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class TopTree::NTTau.
      typedef ::ROOT::Shadow::TopTree::NTTau ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTTau*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "leadTrackPt", &sobj->leadTrackPt);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "numSigConeTracks", &sobj->numSigConeTracks);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "numIsoConeTracks", &sobj->numIsoConeTracks);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "decay", &sobj->decay);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "isolationPFChargedHadrCandsPtSum", &sobj->isolationPFChargedHadrCandsPtSum);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "isolationPFGammaCandsEtSum", &sobj->isolationPFGammaCandsEtSum);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "maximumHCALPFClusterEt", &sobj->maximumHCALPFClusterEt);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "emFraction", &sobj->emFraction);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "hcalTotOverPLead", &sobj->hcalTotOverPLead);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "hcalMaxOverPLead", &sobj->hcalMaxOverPLead);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "hcal3x3OverPLead", &sobj->hcal3x3OverPLead);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ecalStripSumEOverPLead", &sobj->ecalStripSumEOverPLead);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "decayMode", &sobj->decayMode);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "tauIDs", (void*)&sobj->tauIDs);
      R__insp.InspectMember("vector<std::pair<std::string,float> >", (void*)&sobj->tauIDs, "tauIDs.", false);
      R__insp.GenericShowMembers("TopTree::NTLepton", ( ::TopTree::NTLepton * )( (::TopTree::NTTau*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TopTreecLcLNTTau(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTTau : new ::TopTree::NTTau;
   }
   static void *newArray_TopTreecLcLNTTau(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTTau[nElements] : new ::TopTree::NTTau[nElements];
   }
   // Wrapper around operator delete
   static void delete_TopTreecLcLNTTau(void *p) {
      delete ((::TopTree::NTTau*)p);
   }
   static void deleteArray_TopTreecLcLNTTau(void *p) {
      delete [] ((::TopTree::NTTau*)p);
   }
   static void destruct_TopTreecLcLNTTau(void *p) {
      typedef ::TopTree::NTTau current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TopTree::NTTau

//______________________________________________________________________________
namespace ROOT {
   void TopTreecLcLNTTrack_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class TopTree::NTTrack.
      typedef ::ROOT::Shadow::TopTree::NTTrack ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTTrack*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p4", &sobj->p4);
      R__insp.InspectMember(sobj->p4, "p4.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "charge", &sobj->charge);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Chi2", &sobj->Chi2);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "d0", &sobj->d0);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "d0Error", &sobj->d0Error);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "dxy", &sobj->dxy);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "dxy_BS", &sobj->dxy_BS);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "dxyError", &sobj->dxyError);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "dz", &sobj->dz);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "dzError", &sobj->dzError);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TopTreecLcLNTTrack(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTTrack : new ::TopTree::NTTrack;
   }
   static void *newArray_TopTreecLcLNTTrack(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTTrack[nElements] : new ::TopTree::NTTrack[nElements];
   }
   // Wrapper around operator delete
   static void delete_TopTreecLcLNTTrack(void *p) {
      delete ((::TopTree::NTTrack*)p);
   }
   static void deleteArray_TopTreecLcLNTTrack(void *p) {
      delete [] ((::TopTree::NTTrack*)p);
   }
   static void destruct_TopTreecLcLNTTrack(void *p) {
      typedef ::TopTree::NTTrack current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TopTree::NTTrack

//______________________________________________________________________________
namespace ROOT {
   void TopTreecLcLNTVertex_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class TopTree::NTVertex.
      typedef ::ROOT::Shadow::TopTree::NTVertex ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTVertex*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p3", &sobj->p3);
      R__insp.InspectMember(sobj->p3, "p3.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "chi2", &sobj->chi2);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "isFake", &sobj->isFake);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "isValid", &sobj->isValid);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ndof", &sobj->ndof);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "rho", &sobj->rho);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "normalizedChi2", &sobj->normalizedChi2);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NumberOfTracks", &sobj->NumberOfTracks);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TopTreecLcLNTVertex(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTVertex : new ::TopTree::NTVertex;
   }
   static void *newArray_TopTreecLcLNTVertex(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTVertex[nElements] : new ::TopTree::NTVertex[nElements];
   }
   // Wrapper around operator delete
   static void delete_TopTreecLcLNTVertex(void *p) {
      delete ((::TopTree::NTVertex*)p);
   }
   static void deleteArray_TopTreecLcLNTVertex(void *p) {
      delete [] ((::TopTree::NTVertex*)p);
   }
   static void destruct_TopTreecLcLNTVertex(void *p) {
      typedef ::TopTree::NTVertex current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TopTree::NTVertex

//______________________________________________________________________________
namespace ROOT {
   void TopTreecLcLNTJet_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class TopTree::NTJet.
      typedef ::ROOT::Shadow::TopTree::NTJet ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTJet*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p4", &sobj->p4);
      R__insp.InspectMember(sobj->p4, "p4.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p4Gen", &sobj->p4Gen);
      R__insp.InspectMember(sobj->p4Gen, "p4Gen.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p4Parton", &sobj->p4Parton);
      R__insp.InspectMember(sobj->p4Parton, "p4Parton.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p4HLT", &sobj->p4HLT);
      R__insp.InspectMember(sobj->p4HLT, "p4HLT.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "emEnergyFraction", &sobj->emEnergyFraction);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "hadEnergyFraction", &sobj->hadEnergyFraction);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "CHEF", &sobj->CHEF);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "CEEF", &sobj->CEEF);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NHEF", &sobj->NHEF);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NEEF", &sobj->NEEF);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "n90Hits", &sobj->n90Hits);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fHPD", &sobj->fHPD);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "passJetID", &sobj->passJetID);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "partonFlavour", &sobj->partonFlavour);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "DiscriPair", (void*)&sobj->DiscriPair);
      R__insp.InspectMember("vector<std::pair<std::string,float> >", (void*)&sobj->DiscriPair, "DiscriPair.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TCDiscri", &sobj->TCDiscri);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "SVDiscri", &sobj->SVDiscri);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "SMDiscri", &sobj->SMDiscri);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nTracks", &sobj->nTracks);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "sumPtTracks", &sobj->sumPtTracks);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nTracksSVX", &sobj->nTracksSVX);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nSVX", &sobj->nSVX);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "chi2SVX", &sobj->chi2SVX);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ndofSVX", &sobj->ndofSVX);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "flightDistanceSVX", &sobj->flightDistanceSVX);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "flightDistanceSigSVX", &sobj->flightDistanceSigSVX);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "flightDistanceErrSVX", &sobj->flightDistanceErrSVX);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "MassSVX", &sobj->MassSVX);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "turnOnWeight", &sobj->turnOnWeight);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "corrJES", &sobj->corrJES);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TopTreecLcLNTJet(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTJet : new ::TopTree::NTJet;
   }
   static void *newArray_TopTreecLcLNTJet(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTJet[nElements] : new ::TopTree::NTJet[nElements];
   }
   // Wrapper around operator delete
   static void delete_TopTreecLcLNTJet(void *p) {
      delete ((::TopTree::NTJet*)p);
   }
   static void deleteArray_TopTreecLcLNTJet(void *p) {
      delete [] ((::TopTree::NTJet*)p);
   }
   static void destruct_TopTreecLcLNTJet(void *p) {
      typedef ::TopTree::NTJet current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TopTree::NTJet

//______________________________________________________________________________
namespace ROOT {
   void TopTreecLcLNTMET_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class TopTree::NTMET.
      typedef ::ROOT::Shadow::TopTree::NTMET ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTMET*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p4", &sobj->p4);
      R__insp.InspectMember(sobj->p4, "p4.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "correction", &sobj->correction);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "turnOnWeight", &sobj->turnOnWeight);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TopTreecLcLNTMET(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTMET : new ::TopTree::NTMET;
   }
   static void *newArray_TopTreecLcLNTMET(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTMET[nElements] : new ::TopTree::NTMET[nElements];
   }
   // Wrapper around operator delete
   static void delete_TopTreecLcLNTMET(void *p) {
      delete ((::TopTree::NTMET*)p);
   }
   static void deleteArray_TopTreecLcLNTMET(void *p) {
      delete [] ((::TopTree::NTMET*)p);
   }
   static void destruct_TopTreecLcLNTMET(void *p) {
      typedef ::TopTree::NTMET current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TopTree::NTMET

//______________________________________________________________________________
namespace ROOT {
   void TopTreecLcLNTJetMet_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class TopTree::NTJetMet.
      typedef ::ROOT::Shadow::TopTree::NTJetMet ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTJetMet*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "met", (void*)&sobj->met);
      R__insp.InspectMember("TopTree::NTMET", (void*)&sobj->met, "met.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "sumEtJet", &sobj->sumEtJet);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "sumEtJetRaw", &sobj->sumEtJetRaw);
      R__insp.GenericShowMembers("TopTree::NTCollection<TopTree::NTJet>", ( ::TopTree::NTCollection<TopTree::NTJet> * )( (::TopTree::NTJetMet*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TopTreecLcLNTJetMet(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTJetMet : new ::TopTree::NTJetMet;
   }
   static void *newArray_TopTreecLcLNTJetMet(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTJetMet[nElements] : new ::TopTree::NTJetMet[nElements];
   }
   // Wrapper around operator delete
   static void delete_TopTreecLcLNTJetMet(void *p) {
      delete ((::TopTree::NTJetMet*)p);
   }
   static void deleteArray_TopTreecLcLNTJetMet(void *p) {
      delete [] ((::TopTree::NTJetMet*)p);
   }
   static void destruct_TopTreecLcLNTJetMet(void *p) {
      typedef ::TopTree::NTJetMet current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TopTree::NTJetMet

//______________________________________________________________________________
namespace ROOT {
   void TopTreecLcLNTCollectionlETopTreecLcLNTTaugR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class TopTree::NTCollection<TopTree::NTTau>.
      typedef ::ROOT::Shadow::TopTree::NTCollectionlETopTreecLcLNTTaugR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTCollection<TopTree::NTTau>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "objects", (void*)&sobj->objects);
      R__insp.InspectMember("vector<TopTree::NTTau>", (void*)&sobj->objects, "objects.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "algo", (void*)&sobj->algo);
      R__insp.InspectMember("string", (void*)&sobj->algo, "algo.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTCollection<TopTree::NTTau> : new ::TopTree::NTCollection<TopTree::NTTau>;
   }
   static void *newArray_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTCollection<TopTree::NTTau>[nElements] : new ::TopTree::NTCollection<TopTree::NTTau>[nElements];
   }
   // Wrapper around operator delete
   static void delete_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR(void *p) {
      delete ((::TopTree::NTCollection<TopTree::NTTau>*)p);
   }
   static void deleteArray_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR(void *p) {
      delete [] ((::TopTree::NTCollection<TopTree::NTTau>*)p);
   }
   static void destruct_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR(void *p) {
      typedef ::TopTree::NTCollection<TopTree::NTTau> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TopTree::NTCollection<TopTree::NTTau>

//______________________________________________________________________________
namespace ROOT {
   void TopTreecLcLNTCollectionlETopTreecLcLNTJetgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class TopTree::NTCollection<TopTree::NTJet>.
      typedef ::ROOT::Shadow::TopTree::NTCollectionlETopTreecLcLNTJetgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTCollection<TopTree::NTJet>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "objects", (void*)&sobj->objects);
      R__insp.InspectMember("vector<TopTree::NTJet>", (void*)&sobj->objects, "objects.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "algo", (void*)&sobj->algo);
      R__insp.InspectMember("string", (void*)&sobj->algo, "algo.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTCollection<TopTree::NTJet> : new ::TopTree::NTCollection<TopTree::NTJet>;
   }
   static void *newArray_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTCollection<TopTree::NTJet>[nElements] : new ::TopTree::NTCollection<TopTree::NTJet>[nElements];
   }
   // Wrapper around operator delete
   static void delete_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR(void *p) {
      delete ((::TopTree::NTCollection<TopTree::NTJet>*)p);
   }
   static void deleteArray_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR(void *p) {
      delete [] ((::TopTree::NTCollection<TopTree::NTJet>*)p);
   }
   static void destruct_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR(void *p) {
      typedef ::TopTree::NTCollection<TopTree::NTJet> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TopTree::NTCollection<TopTree::NTJet>

//______________________________________________________________________________
namespace ROOT {
   void TopTreecLcLNTEvent_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class TopTree::NTEvent.
      typedef ::ROOT::Shadow::TopTree::NTEvent ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTEvent*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "runNb", &sobj->runNb);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "eventNb", &sobj->eventNb);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "eventWeight", &sobj->eventWeight);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "lumiblock", &sobj->lumiblock);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "procId", &sobj->procId);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "eventType", (void*)&sobj->eventType);
      R__insp.InspectMember("string", (void*)&sobj->eventType, "eventType.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TMEME", &sobj->TMEME);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ptHat", &sobj->ptHat);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "pdgIdPartons", (void*)&sobj->pdgIdPartons);
      R__insp.InspectMember("pair<int,int>", (void*)&sobj->pdgIdPartons, "pdgIdPartons.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "triggers", (void*)&sobj->triggers);
      R__insp.InspectMember("vector<std::pair<std::string,bool> >", (void*)&sobj->triggers, "triggers.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "match_HLT_Ele10_LW_L1R_recoEl", &sobj->match_HLT_Ele10_LW_L1R_recoEl);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "prescales", (void*)&sobj->prescales);
      R__insp.InspectMember("vector<std::pair<std::string,int> >", (void*)&sobj->prescales, "prescales.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "tauObjTrig", (void*)&sobj->tauObjTrig);
      R__insp.InspectMember("vector<TLorentzVector>", (void*)&sobj->tauObjTrig, "tauObjTrig.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "jetObjTrig", (void*)&sobj->jetObjTrig);
      R__insp.InspectMember("vector<TLorentzVector>", (void*)&sobj->jetObjTrig, "jetObjTrig.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "VertexVec", (void*)&sobj->VertexVec);
      R__insp.InspectMember("vector<NTVertex>", (void*)&sobj->VertexVec, "VertexVec.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p3BS", &sobj->p3BS);
      R__insp.InspectMember(sobj->p3BS, "p3BS.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p3BSErr", &sobj->p3BSErr);
      R__insp.InspectMember(sobj->p3BSErr, "p3BSErr.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "rho_PUUE_dens", &sobj->rho_PUUE_dens);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "neutralRho_PUUE_dens", &sobj->neutralRho_PUUE_dens);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "num_pileup_bc0", &sobj->num_pileup_bc0);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "num_pileup_bcp1", &sobj->num_pileup_bcp1);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "num_pileup_bcm1", &sobj->num_pileup_bcm1);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "pileup", (void*)&sobj->pileup);
      R__insp.InspectMember("vector<NTPU>", (void*)&sobj->pileup, "pileup.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "jetMetVec", (void*)&sobj->jetMetVec);
      R__insp.InspectMember("vector<NTJetMet>", (void*)&sobj->jetMetVec, "jetMetVec.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "electrons", (void*)&sobj->electrons);
      R__insp.InspectMember("vector<NTElectron>", (void*)&sobj->electrons, "electrons.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "muons", (void*)&sobj->muons);
      R__insp.InspectMember("vector<NTMuon>", (void*)&sobj->muons, "muons.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "tausVec", (void*)&sobj->tausVec);
      R__insp.InspectMember("vector<TopTree::NTCollection<NTTau> >", (void*)&sobj->tausVec, "tausVec.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "photons", (void*)&sobj->photons);
      R__insp.InspectMember("vector<NTPhoton>", (void*)&sobj->photons, "photons.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "tracks", (void*)&sobj->tracks);
      R__insp.InspectMember("vector<NTTrack>", (void*)&sobj->tracks, "tracks.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Generatedtaus", (void*)&sobj->Generatedtaus);
      R__insp.InspectMember("vector<TLorentzVector>", (void*)&sobj->Generatedtaus, "Generatedtaus.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "GeneratedAtaus", (void*)&sobj->GeneratedAtaus);
      R__insp.InspectMember("vector<TLorentzVector>", (void*)&sobj->GeneratedAtaus, "GeneratedAtaus.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "genBquarks", (void*)&sobj->genBquarks);
      R__insp.InspectMember("vector<TLorentzVector>", (void*)&sobj->genBquarks, "genBquarks.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "genCquarks", (void*)&sobj->genCquarks);
      R__insp.InspectMember("vector<TLorentzVector>", (void*)&sobj->genCquarks, "genCquarks.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "genLquarks", (void*)&sobj->genLquarks);
      R__insp.InspectMember("vector<TLorentzVector>", (void*)&sobj->genLquarks, "genLquarks.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "genGquarks", (void*)&sobj->genGquarks);
      R__insp.InspectMember("vector<TLorentzVector>", (void*)&sobj->genGquarks, "genGquarks.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "wAndDecays", (void*)&sobj->wAndDecays);
      R__insp.InspectMember("vector<WDecaysMC>", (void*)&sobj->wAndDecays, "wAndDecays.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "zAndDecays", (void*)&sobj->zAndDecays);
      R__insp.InspectMember("vector<ZDecaysMC>", (void*)&sobj->zAndDecays, "zAndDecays.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "topAndDecays", (void*)&sobj->topAndDecays);
      R__insp.InspectMember("vector<TopDecaysMC>", (void*)&sobj->topAndDecays, "topAndDecays.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "GeneratedtausLepPlusDecays", (void*)&sobj->GeneratedtausLepPlusDecays);
      R__insp.InspectMember("vector<std::vector<TLorentzVector> >", (void*)&sobj->GeneratedtausLepPlusDecays, "GeneratedtausLepPlusDecays.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "GeneratedtausLepMinusDecays", (void*)&sobj->GeneratedtausLepMinusDecays);
      R__insp.InspectMember("vector<std::vector<TLorentzVector> >", (void*)&sobj->GeneratedtausLepMinusDecays, "GeneratedtausLepMinusDecays.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "GeneratedtausPionPlusDecays", (void*)&sobj->GeneratedtausPionPlusDecays);
      R__insp.InspectMember("vector<std::vector<TLorentzVector> >", (void*)&sobj->GeneratedtausPionPlusDecays, "GeneratedtausPionPlusDecays.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "GeneratedtausPionMinusDecays", (void*)&sobj->GeneratedtausPionMinusDecays);
      R__insp.InspectMember("vector<std::vector<TLorentzVector> >", (void*)&sobj->GeneratedtausPionMinusDecays, "GeneratedtausPionMinusDecays.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "wPlusAndDecays", (void*)&sobj->wPlusAndDecays);
      R__insp.InspectMember("vector<WDecaysMC>", (void*)&sobj->wPlusAndDecays, "wPlusAndDecays.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "wMinusAndDecays", (void*)&sobj->wMinusAndDecays);
      R__insp.InspectMember("vector<WDecaysMC>", (void*)&sobj->wMinusAndDecays, "wMinusAndDecays.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "topPlusAndDecays", (void*)&sobj->topPlusAndDecays);
      R__insp.InspectMember("vector<TopDecaysMC>", (void*)&sobj->topPlusAndDecays, "topPlusAndDecays.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "topMinusAndDecays", (void*)&sobj->topMinusAndDecays);
      R__insp.InspectMember("vector<TopDecaysMC>", (void*)&sobj->topMinusAndDecays, "topMinusAndDecays.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "pdfWeights", (void*)&sobj->pdfWeights);
      R__insp.InspectMember("vector<float>", (void*)&sobj->pdfWeights, "pdfWeights.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "partonFlavor1", &sobj->partonFlavor1);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "partonFlavor2", &sobj->partonFlavor2);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "x1", &sobj->x1);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "x2", &sobj->x2);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Q_scale", &sobj->Q_scale);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TopTreecLcLNTEvent(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTEvent : new ::TopTree::NTEvent;
   }
   static void *newArray_TopTreecLcLNTEvent(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTEvent[nElements] : new ::TopTree::NTEvent[nElements];
   }
   // Wrapper around operator delete
   static void delete_TopTreecLcLNTEvent(void *p) {
      delete ((::TopTree::NTEvent*)p);
   }
   static void deleteArray_TopTreecLcLNTEvent(void *p) {
      delete [] ((::TopTree::NTEvent*)p);
   }
   static void destruct_TopTreecLcLNTEvent(void *p) {
      typedef ::TopTree::NTEvent current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TopTree::NTEvent

//______________________________________________________________________________
namespace ROOT {
   void TopTreecLcLWDecaysMC_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class TopTree::WDecaysMC.
      typedef ::ROOT::Shadow::TopTree::WDecaysMC ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TopTree::WDecaysMC*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Q_Lep_gen", &sobj->Q_Lep_gen);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p4_W_gen", &sobj->p4_W_gen);
      R__insp.InspectMember(sobj->p4_W_gen, "p4_W_gen.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p4_Lep_gen", &sobj->p4_Lep_gen);
      R__insp.InspectMember(sobj->p4_Lep_gen, "p4_Lep_gen.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p4_Neu_gen", &sobj->p4_Neu_gen);
      R__insp.InspectMember(sobj->p4_Neu_gen, "p4_Neu_gen.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p4_SumTauNeu_gen", &sobj->p4_SumTauNeu_gen);
      R__insp.InspectMember(sobj->p4_SumTauNeu_gen, "p4_SumTauNeu_gen.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Tmeme", &sobj->Tmeme);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mcLepId", &sobj->mcLepId);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TopTreecLcLWDecaysMC(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::WDecaysMC : new ::TopTree::WDecaysMC;
   }
   static void *newArray_TopTreecLcLWDecaysMC(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::WDecaysMC[nElements] : new ::TopTree::WDecaysMC[nElements];
   }
   // Wrapper around operator delete
   static void delete_TopTreecLcLWDecaysMC(void *p) {
      delete ((::TopTree::WDecaysMC*)p);
   }
   static void deleteArray_TopTreecLcLWDecaysMC(void *p) {
      delete [] ((::TopTree::WDecaysMC*)p);
   }
   static void destruct_TopTreecLcLWDecaysMC(void *p) {
      typedef ::TopTree::WDecaysMC current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TopTree::WDecaysMC

//______________________________________________________________________________
namespace ROOT {
   void TopTreecLcLZDecaysMC_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class TopTree::ZDecaysMC.
      typedef ::ROOT::Shadow::TopTree::ZDecaysMC ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TopTree::ZDecaysMC*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p4_Z_gen", &sobj->p4_Z_gen);
      R__insp.InspectMember(sobj->p4_Z_gen, "p4_Z_gen.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p4_Lep1_gen", &sobj->p4_Lep1_gen);
      R__insp.InspectMember(sobj->p4_Lep1_gen, "p4_Lep1_gen.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p4_Lep2_gen", &sobj->p4_Lep2_gen);
      R__insp.InspectMember(sobj->p4_Lep2_gen, "p4_Lep2_gen.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p4_SumTauNeu_gen", &sobj->p4_SumTauNeu_gen);
      R__insp.InspectMember(sobj->p4_SumTauNeu_gen, "p4_SumTauNeu_gen.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p4_SumTauANeu_gen", &sobj->p4_SumTauANeu_gen);
      R__insp.InspectMember(sobj->p4_SumTauANeu_gen, "p4_SumTauANeu_gen.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Q_Lep1_gen", &sobj->Q_Lep1_gen);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Q_Lep2_gen", &sobj->Q_Lep2_gen);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Lep1_pdgID", &sobj->Lep1_pdgID);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Lep2_pdgID", &sobj->Lep2_pdgID);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Tmeme", &sobj->Tmeme);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Zgtobb", &sobj->Zgtobb);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TopTreecLcLZDecaysMC(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::ZDecaysMC : new ::TopTree::ZDecaysMC;
   }
   static void *newArray_TopTreecLcLZDecaysMC(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::ZDecaysMC[nElements] : new ::TopTree::ZDecaysMC[nElements];
   }
   // Wrapper around operator delete
   static void delete_TopTreecLcLZDecaysMC(void *p) {
      delete ((::TopTree::ZDecaysMC*)p);
   }
   static void deleteArray_TopTreecLcLZDecaysMC(void *p) {
      delete [] ((::TopTree::ZDecaysMC*)p);
   }
   static void destruct_TopTreecLcLZDecaysMC(void *p) {
      typedef ::TopTree::ZDecaysMC current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TopTree::ZDecaysMC

//______________________________________________________________________________
namespace ROOT {
   void TopTreecLcLTopDecaysMC_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class TopTree::TopDecaysMC.
      typedef ::ROOT::Shadow::TopTree::TopDecaysMC ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TopTree::TopDecaysMC*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Q_gen", &sobj->Q_gen);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p4_b_gen", &sobj->p4_b_gen);
      R__insp.InspectMember(sobj->p4_b_gen, "p4_b_gen.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "p4_t_gen", &sobj->p4_t_gen);
      R__insp.InspectMember(sobj->p4_t_gen, "p4_t_gen.");
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mcLepId", &sobj->mcLepId);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TopTreecLcLTopDecaysMC(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::TopDecaysMC : new ::TopTree::TopDecaysMC;
   }
   static void *newArray_TopTreecLcLTopDecaysMC(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::TopDecaysMC[nElements] : new ::TopTree::TopDecaysMC[nElements];
   }
   // Wrapper around operator delete
   static void delete_TopTreecLcLTopDecaysMC(void *p) {
      delete ((::TopTree::TopDecaysMC*)p);
   }
   static void deleteArray_TopTreecLcLTopDecaysMC(void *p) {
      delete [] ((::TopTree::TopDecaysMC*)p);
   }
   static void destruct_TopTreecLcLTopDecaysMC(void *p) {
      typedef ::TopTree::TopDecaysMC current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TopTree::TopDecaysMC

//______________________________________________________________________________
namespace ROOT {
   void pairlEstringcOboolgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class pair<string,bool>.
      typedef ::ROOT::Shadow::pairlEstringcOboolgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<string,bool>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "first", (void*)&sobj->first);
      R__insp.InspectMember("string", (void*)&sobj->first, "first.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEstringcOboolgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<string,bool> : new pair<string,bool>;
   }
   static void *newArray_pairlEstringcOboolgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<string,bool>[nElements] : new pair<string,bool>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEstringcOboolgR(void *p) {
      delete ((pair<string,bool>*)p);
   }
   static void deleteArray_pairlEstringcOboolgR(void *p) {
      delete [] ((pair<string,bool>*)p);
   }
   static void destruct_pairlEstringcOboolgR(void *p) {
      typedef pair<string,bool> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<string,bool>

//______________________________________________________________________________
namespace ROOT {
   void TopTreecLcLNTPU_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class TopTree::NTPU.
      typedef ::ROOT::Shadow::TopTree::NTPU ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TopTree::NTPU*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "bunchCrossing", &sobj->bunchCrossing);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "zpositions", &sobj->zpositions);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "sumpT_lowpT", &sobj->sumpT_lowpT);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "sumpT_highpT", &sobj->sumpT_highpT);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ntrks_lowpT", &sobj->ntrks_lowpT);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ntrks_highpT", &sobj->ntrks_highpT);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TopTreecLcLNTPU(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTPU : new ::TopTree::NTPU;
   }
   static void *newArray_TopTreecLcLNTPU(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TopTree::NTPU[nElements] : new ::TopTree::NTPU[nElements];
   }
   // Wrapper around operator delete
   static void delete_TopTreecLcLNTPU(void *p) {
      delete ((::TopTree::NTPU*)p);
   }
   static void deleteArray_TopTreecLcLNTPU(void *p) {
      delete [] ((::TopTree::NTPU*)p);
   }
   static void destruct_TopTreecLcLNTPU(void *p) {
      typedef ::TopTree::NTPU current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TopTree::NTPU

namespace ROOT {
   void vectorlETLorentzVectorgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlETLorentzVectorgR_Dictionary();
   static void *new_vectorlETLorentzVectorgR(void *p = 0);
   static void *newArray_vectorlETLorentzVectorgR(Long_t size, void *p);
   static void delete_vectorlETLorentzVectorgR(void *p);
   static void deleteArray_vectorlETLorentzVectorgR(void *p);
   static void destruct_vectorlETLorentzVectorgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TLorentzVector>*)
   {
      vector<TLorentzVector> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TLorentzVector>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<TLorentzVector>", -2, "prec_stl/vector", 49,
                  typeid(vector<TLorentzVector>), DefineBehavior(ptr, ptr),
                  0, &vectorlETLorentzVectorgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<TLorentzVector>) );
      instance.SetNew(&new_vectorlETLorentzVectorgR);
      instance.SetNewArray(&newArray_vectorlETLorentzVectorgR);
      instance.SetDelete(&delete_vectorlETLorentzVectorgR);
      instance.SetDeleteArray(&deleteArray_vectorlETLorentzVectorgR);
      instance.SetDestructor(&destruct_vectorlETLorentzVectorgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TLorentzVector> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<TLorentzVector>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETLorentzVectorgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<TLorentzVector>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETLorentzVectorgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TLorentzVector> : new vector<TLorentzVector>;
   }
   static void *newArray_vectorlETLorentzVectorgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TLorentzVector>[nElements] : new vector<TLorentzVector>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETLorentzVectorgR(void *p) {
      delete ((vector<TLorentzVector>*)p);
   }
   static void deleteArray_vectorlETLorentzVectorgR(void *p) {
      delete [] ((vector<TLorentzVector>*)p);
   }
   static void destruct_vectorlETLorentzVectorgR(void *p) {
      typedef vector<TLorentzVector> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TLorentzVector>

namespace ROOT {
   void vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgR_Dictionary();
   static void *new_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgR(void *p = 0);
   static void *newArray_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgR(Long_t size, void *p);
   static void delete_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgR(void *p);
   static void deleteArray_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgR(void *p);
   static void destruct_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TopTree::NTCollection<TopTree::NTTau> >*)
   {
      vector<TopTree::NTCollection<TopTree::NTTau> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TopTree::NTCollection<TopTree::NTTau> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<TopTree::NTCollection<TopTree::NTTau> >", -2, "prec_stl/vector", 49,
                  typeid(vector<TopTree::NTCollection<TopTree::NTTau> >), DefineBehavior(ptr, ptr),
                  0, &vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<TopTree::NTCollection<TopTree::NTTau> >) );
      instance.SetNew(&new_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgR);
      instance.SetNewArray(&newArray_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgR);
      instance.SetDelete(&delete_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgR);
      instance.SetDestructor(&destruct_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TopTree::NTCollection<TopTree::NTTau> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<TopTree::NTCollection<TopTree::NTTau> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<TopTree::NTCollection<TopTree::NTTau> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::NTCollection<TopTree::NTTau> > : new vector<TopTree::NTCollection<TopTree::NTTau> >;
   }
   static void *newArray_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::NTCollection<TopTree::NTTau> >[nElements] : new vector<TopTree::NTCollection<TopTree::NTTau> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgR(void *p) {
      delete ((vector<TopTree::NTCollection<TopTree::NTTau> >*)p);
   }
   static void deleteArray_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgR(void *p) {
      delete [] ((vector<TopTree::NTCollection<TopTree::NTTau> >*)p);
   }
   static void destruct_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgR(void *p) {
      typedef vector<TopTree::NTCollection<TopTree::NTTau> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TopTree::NTCollection<TopTree::NTTau> >

namespace ROOT {
   void vectorlETopTreecLcLNTElectrongR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlETopTreecLcLNTElectrongR_Dictionary();
   static void *new_vectorlETopTreecLcLNTElectrongR(void *p = 0);
   static void *newArray_vectorlETopTreecLcLNTElectrongR(Long_t size, void *p);
   static void delete_vectorlETopTreecLcLNTElectrongR(void *p);
   static void deleteArray_vectorlETopTreecLcLNTElectrongR(void *p);
   static void destruct_vectorlETopTreecLcLNTElectrongR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TopTree::NTElectron>*)
   {
      vector<TopTree::NTElectron> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TopTree::NTElectron>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<TopTree::NTElectron>", -2, "prec_stl/vector", 49,
                  typeid(vector<TopTree::NTElectron>), DefineBehavior(ptr, ptr),
                  0, &vectorlETopTreecLcLNTElectrongR_Dictionary, isa_proxy, 0,
                  sizeof(vector<TopTree::NTElectron>) );
      instance.SetNew(&new_vectorlETopTreecLcLNTElectrongR);
      instance.SetNewArray(&newArray_vectorlETopTreecLcLNTElectrongR);
      instance.SetDelete(&delete_vectorlETopTreecLcLNTElectrongR);
      instance.SetDeleteArray(&deleteArray_vectorlETopTreecLcLNTElectrongR);
      instance.SetDestructor(&destruct_vectorlETopTreecLcLNTElectrongR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TopTree::NTElectron> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<TopTree::NTElectron>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETopTreecLcLNTElectrongR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<TopTree::NTElectron>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETopTreecLcLNTElectrongR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::NTElectron> : new vector<TopTree::NTElectron>;
   }
   static void *newArray_vectorlETopTreecLcLNTElectrongR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::NTElectron>[nElements] : new vector<TopTree::NTElectron>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETopTreecLcLNTElectrongR(void *p) {
      delete ((vector<TopTree::NTElectron>*)p);
   }
   static void deleteArray_vectorlETopTreecLcLNTElectrongR(void *p) {
      delete [] ((vector<TopTree::NTElectron>*)p);
   }
   static void destruct_vectorlETopTreecLcLNTElectrongR(void *p) {
      typedef vector<TopTree::NTElectron> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TopTree::NTElectron>

namespace ROOT {
   void vectorlETopTreecLcLNTJetgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlETopTreecLcLNTJetgR_Dictionary();
   static void *new_vectorlETopTreecLcLNTJetgR(void *p = 0);
   static void *newArray_vectorlETopTreecLcLNTJetgR(Long_t size, void *p);
   static void delete_vectorlETopTreecLcLNTJetgR(void *p);
   static void deleteArray_vectorlETopTreecLcLNTJetgR(void *p);
   static void destruct_vectorlETopTreecLcLNTJetgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TopTree::NTJet>*)
   {
      vector<TopTree::NTJet> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TopTree::NTJet>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<TopTree::NTJet>", -2, "prec_stl/vector", 49,
                  typeid(vector<TopTree::NTJet>), DefineBehavior(ptr, ptr),
                  0, &vectorlETopTreecLcLNTJetgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<TopTree::NTJet>) );
      instance.SetNew(&new_vectorlETopTreecLcLNTJetgR);
      instance.SetNewArray(&newArray_vectorlETopTreecLcLNTJetgR);
      instance.SetDelete(&delete_vectorlETopTreecLcLNTJetgR);
      instance.SetDeleteArray(&deleteArray_vectorlETopTreecLcLNTJetgR);
      instance.SetDestructor(&destruct_vectorlETopTreecLcLNTJetgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TopTree::NTJet> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<TopTree::NTJet>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETopTreecLcLNTJetgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<TopTree::NTJet>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETopTreecLcLNTJetgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::NTJet> : new vector<TopTree::NTJet>;
   }
   static void *newArray_vectorlETopTreecLcLNTJetgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::NTJet>[nElements] : new vector<TopTree::NTJet>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETopTreecLcLNTJetgR(void *p) {
      delete ((vector<TopTree::NTJet>*)p);
   }
   static void deleteArray_vectorlETopTreecLcLNTJetgR(void *p) {
      delete [] ((vector<TopTree::NTJet>*)p);
   }
   static void destruct_vectorlETopTreecLcLNTJetgR(void *p) {
      typedef vector<TopTree::NTJet> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TopTree::NTJet>

namespace ROOT {
   void vectorlETopTreecLcLNTJetMetgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlETopTreecLcLNTJetMetgR_Dictionary();
   static void *new_vectorlETopTreecLcLNTJetMetgR(void *p = 0);
   static void *newArray_vectorlETopTreecLcLNTJetMetgR(Long_t size, void *p);
   static void delete_vectorlETopTreecLcLNTJetMetgR(void *p);
   static void deleteArray_vectorlETopTreecLcLNTJetMetgR(void *p);
   static void destruct_vectorlETopTreecLcLNTJetMetgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TopTree::NTJetMet>*)
   {
      vector<TopTree::NTJetMet> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TopTree::NTJetMet>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<TopTree::NTJetMet>", -2, "prec_stl/vector", 49,
                  typeid(vector<TopTree::NTJetMet>), DefineBehavior(ptr, ptr),
                  0, &vectorlETopTreecLcLNTJetMetgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<TopTree::NTJetMet>) );
      instance.SetNew(&new_vectorlETopTreecLcLNTJetMetgR);
      instance.SetNewArray(&newArray_vectorlETopTreecLcLNTJetMetgR);
      instance.SetDelete(&delete_vectorlETopTreecLcLNTJetMetgR);
      instance.SetDeleteArray(&deleteArray_vectorlETopTreecLcLNTJetMetgR);
      instance.SetDestructor(&destruct_vectorlETopTreecLcLNTJetMetgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TopTree::NTJetMet> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<TopTree::NTJetMet>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETopTreecLcLNTJetMetgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<TopTree::NTJetMet>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETopTreecLcLNTJetMetgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::NTJetMet> : new vector<TopTree::NTJetMet>;
   }
   static void *newArray_vectorlETopTreecLcLNTJetMetgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::NTJetMet>[nElements] : new vector<TopTree::NTJetMet>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETopTreecLcLNTJetMetgR(void *p) {
      delete ((vector<TopTree::NTJetMet>*)p);
   }
   static void deleteArray_vectorlETopTreecLcLNTJetMetgR(void *p) {
      delete [] ((vector<TopTree::NTJetMet>*)p);
   }
   static void destruct_vectorlETopTreecLcLNTJetMetgR(void *p) {
      typedef vector<TopTree::NTJetMet> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TopTree::NTJetMet>

namespace ROOT {
   void vectorlETopTreecLcLNTMuongR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlETopTreecLcLNTMuongR_Dictionary();
   static void *new_vectorlETopTreecLcLNTMuongR(void *p = 0);
   static void *newArray_vectorlETopTreecLcLNTMuongR(Long_t size, void *p);
   static void delete_vectorlETopTreecLcLNTMuongR(void *p);
   static void deleteArray_vectorlETopTreecLcLNTMuongR(void *p);
   static void destruct_vectorlETopTreecLcLNTMuongR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TopTree::NTMuon>*)
   {
      vector<TopTree::NTMuon> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TopTree::NTMuon>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<TopTree::NTMuon>", -2, "prec_stl/vector", 49,
                  typeid(vector<TopTree::NTMuon>), DefineBehavior(ptr, ptr),
                  0, &vectorlETopTreecLcLNTMuongR_Dictionary, isa_proxy, 0,
                  sizeof(vector<TopTree::NTMuon>) );
      instance.SetNew(&new_vectorlETopTreecLcLNTMuongR);
      instance.SetNewArray(&newArray_vectorlETopTreecLcLNTMuongR);
      instance.SetDelete(&delete_vectorlETopTreecLcLNTMuongR);
      instance.SetDeleteArray(&deleteArray_vectorlETopTreecLcLNTMuongR);
      instance.SetDestructor(&destruct_vectorlETopTreecLcLNTMuongR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TopTree::NTMuon> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<TopTree::NTMuon>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETopTreecLcLNTMuongR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<TopTree::NTMuon>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETopTreecLcLNTMuongR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::NTMuon> : new vector<TopTree::NTMuon>;
   }
   static void *newArray_vectorlETopTreecLcLNTMuongR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::NTMuon>[nElements] : new vector<TopTree::NTMuon>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETopTreecLcLNTMuongR(void *p) {
      delete ((vector<TopTree::NTMuon>*)p);
   }
   static void deleteArray_vectorlETopTreecLcLNTMuongR(void *p) {
      delete [] ((vector<TopTree::NTMuon>*)p);
   }
   static void destruct_vectorlETopTreecLcLNTMuongR(void *p) {
      typedef vector<TopTree::NTMuon> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TopTree::NTMuon>

namespace ROOT {
   void vectorlETopTreecLcLNTPUgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlETopTreecLcLNTPUgR_Dictionary();
   static void *new_vectorlETopTreecLcLNTPUgR(void *p = 0);
   static void *newArray_vectorlETopTreecLcLNTPUgR(Long_t size, void *p);
   static void delete_vectorlETopTreecLcLNTPUgR(void *p);
   static void deleteArray_vectorlETopTreecLcLNTPUgR(void *p);
   static void destruct_vectorlETopTreecLcLNTPUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TopTree::NTPU>*)
   {
      vector<TopTree::NTPU> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TopTree::NTPU>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<TopTree::NTPU>", -2, "prec_stl/vector", 49,
                  typeid(vector<TopTree::NTPU>), DefineBehavior(ptr, ptr),
                  0, &vectorlETopTreecLcLNTPUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<TopTree::NTPU>) );
      instance.SetNew(&new_vectorlETopTreecLcLNTPUgR);
      instance.SetNewArray(&newArray_vectorlETopTreecLcLNTPUgR);
      instance.SetDelete(&delete_vectorlETopTreecLcLNTPUgR);
      instance.SetDeleteArray(&deleteArray_vectorlETopTreecLcLNTPUgR);
      instance.SetDestructor(&destruct_vectorlETopTreecLcLNTPUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TopTree::NTPU> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<TopTree::NTPU>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETopTreecLcLNTPUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<TopTree::NTPU>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETopTreecLcLNTPUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::NTPU> : new vector<TopTree::NTPU>;
   }
   static void *newArray_vectorlETopTreecLcLNTPUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::NTPU>[nElements] : new vector<TopTree::NTPU>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETopTreecLcLNTPUgR(void *p) {
      delete ((vector<TopTree::NTPU>*)p);
   }
   static void deleteArray_vectorlETopTreecLcLNTPUgR(void *p) {
      delete [] ((vector<TopTree::NTPU>*)p);
   }
   static void destruct_vectorlETopTreecLcLNTPUgR(void *p) {
      typedef vector<TopTree::NTPU> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TopTree::NTPU>

namespace ROOT {
   void vectorlETopTreecLcLNTPhotongR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlETopTreecLcLNTPhotongR_Dictionary();
   static void *new_vectorlETopTreecLcLNTPhotongR(void *p = 0);
   static void *newArray_vectorlETopTreecLcLNTPhotongR(Long_t size, void *p);
   static void delete_vectorlETopTreecLcLNTPhotongR(void *p);
   static void deleteArray_vectorlETopTreecLcLNTPhotongR(void *p);
   static void destruct_vectorlETopTreecLcLNTPhotongR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TopTree::NTPhoton>*)
   {
      vector<TopTree::NTPhoton> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TopTree::NTPhoton>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<TopTree::NTPhoton>", -2, "prec_stl/vector", 49,
                  typeid(vector<TopTree::NTPhoton>), DefineBehavior(ptr, ptr),
                  0, &vectorlETopTreecLcLNTPhotongR_Dictionary, isa_proxy, 0,
                  sizeof(vector<TopTree::NTPhoton>) );
      instance.SetNew(&new_vectorlETopTreecLcLNTPhotongR);
      instance.SetNewArray(&newArray_vectorlETopTreecLcLNTPhotongR);
      instance.SetDelete(&delete_vectorlETopTreecLcLNTPhotongR);
      instance.SetDeleteArray(&deleteArray_vectorlETopTreecLcLNTPhotongR);
      instance.SetDestructor(&destruct_vectorlETopTreecLcLNTPhotongR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TopTree::NTPhoton> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<TopTree::NTPhoton>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETopTreecLcLNTPhotongR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<TopTree::NTPhoton>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETopTreecLcLNTPhotongR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::NTPhoton> : new vector<TopTree::NTPhoton>;
   }
   static void *newArray_vectorlETopTreecLcLNTPhotongR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::NTPhoton>[nElements] : new vector<TopTree::NTPhoton>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETopTreecLcLNTPhotongR(void *p) {
      delete ((vector<TopTree::NTPhoton>*)p);
   }
   static void deleteArray_vectorlETopTreecLcLNTPhotongR(void *p) {
      delete [] ((vector<TopTree::NTPhoton>*)p);
   }
   static void destruct_vectorlETopTreecLcLNTPhotongR(void *p) {
      typedef vector<TopTree::NTPhoton> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TopTree::NTPhoton>

namespace ROOT {
   void vectorlETopTreecLcLNTTaugR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlETopTreecLcLNTTaugR_Dictionary();
   static void *new_vectorlETopTreecLcLNTTaugR(void *p = 0);
   static void *newArray_vectorlETopTreecLcLNTTaugR(Long_t size, void *p);
   static void delete_vectorlETopTreecLcLNTTaugR(void *p);
   static void deleteArray_vectorlETopTreecLcLNTTaugR(void *p);
   static void destruct_vectorlETopTreecLcLNTTaugR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TopTree::NTTau>*)
   {
      vector<TopTree::NTTau> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TopTree::NTTau>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<TopTree::NTTau>", -2, "prec_stl/vector", 49,
                  typeid(vector<TopTree::NTTau>), DefineBehavior(ptr, ptr),
                  0, &vectorlETopTreecLcLNTTaugR_Dictionary, isa_proxy, 0,
                  sizeof(vector<TopTree::NTTau>) );
      instance.SetNew(&new_vectorlETopTreecLcLNTTaugR);
      instance.SetNewArray(&newArray_vectorlETopTreecLcLNTTaugR);
      instance.SetDelete(&delete_vectorlETopTreecLcLNTTaugR);
      instance.SetDeleteArray(&deleteArray_vectorlETopTreecLcLNTTaugR);
      instance.SetDestructor(&destruct_vectorlETopTreecLcLNTTaugR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TopTree::NTTau> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<TopTree::NTTau>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETopTreecLcLNTTaugR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<TopTree::NTTau>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETopTreecLcLNTTaugR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::NTTau> : new vector<TopTree::NTTau>;
   }
   static void *newArray_vectorlETopTreecLcLNTTaugR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::NTTau>[nElements] : new vector<TopTree::NTTau>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETopTreecLcLNTTaugR(void *p) {
      delete ((vector<TopTree::NTTau>*)p);
   }
   static void deleteArray_vectorlETopTreecLcLNTTaugR(void *p) {
      delete [] ((vector<TopTree::NTTau>*)p);
   }
   static void destruct_vectorlETopTreecLcLNTTaugR(void *p) {
      typedef vector<TopTree::NTTau> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TopTree::NTTau>

namespace ROOT {
   void vectorlETopTreecLcLNTTrackgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlETopTreecLcLNTTrackgR_Dictionary();
   static void *new_vectorlETopTreecLcLNTTrackgR(void *p = 0);
   static void *newArray_vectorlETopTreecLcLNTTrackgR(Long_t size, void *p);
   static void delete_vectorlETopTreecLcLNTTrackgR(void *p);
   static void deleteArray_vectorlETopTreecLcLNTTrackgR(void *p);
   static void destruct_vectorlETopTreecLcLNTTrackgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TopTree::NTTrack>*)
   {
      vector<TopTree::NTTrack> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TopTree::NTTrack>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<TopTree::NTTrack>", -2, "prec_stl/vector", 49,
                  typeid(vector<TopTree::NTTrack>), DefineBehavior(ptr, ptr),
                  0, &vectorlETopTreecLcLNTTrackgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<TopTree::NTTrack>) );
      instance.SetNew(&new_vectorlETopTreecLcLNTTrackgR);
      instance.SetNewArray(&newArray_vectorlETopTreecLcLNTTrackgR);
      instance.SetDelete(&delete_vectorlETopTreecLcLNTTrackgR);
      instance.SetDeleteArray(&deleteArray_vectorlETopTreecLcLNTTrackgR);
      instance.SetDestructor(&destruct_vectorlETopTreecLcLNTTrackgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TopTree::NTTrack> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<TopTree::NTTrack>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETopTreecLcLNTTrackgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<TopTree::NTTrack>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETopTreecLcLNTTrackgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::NTTrack> : new vector<TopTree::NTTrack>;
   }
   static void *newArray_vectorlETopTreecLcLNTTrackgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::NTTrack>[nElements] : new vector<TopTree::NTTrack>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETopTreecLcLNTTrackgR(void *p) {
      delete ((vector<TopTree::NTTrack>*)p);
   }
   static void deleteArray_vectorlETopTreecLcLNTTrackgR(void *p) {
      delete [] ((vector<TopTree::NTTrack>*)p);
   }
   static void destruct_vectorlETopTreecLcLNTTrackgR(void *p) {
      typedef vector<TopTree::NTTrack> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TopTree::NTTrack>

namespace ROOT {
   void vectorlETopTreecLcLNTVertexgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlETopTreecLcLNTVertexgR_Dictionary();
   static void *new_vectorlETopTreecLcLNTVertexgR(void *p = 0);
   static void *newArray_vectorlETopTreecLcLNTVertexgR(Long_t size, void *p);
   static void delete_vectorlETopTreecLcLNTVertexgR(void *p);
   static void deleteArray_vectorlETopTreecLcLNTVertexgR(void *p);
   static void destruct_vectorlETopTreecLcLNTVertexgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TopTree::NTVertex>*)
   {
      vector<TopTree::NTVertex> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TopTree::NTVertex>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<TopTree::NTVertex>", -2, "prec_stl/vector", 49,
                  typeid(vector<TopTree::NTVertex>), DefineBehavior(ptr, ptr),
                  0, &vectorlETopTreecLcLNTVertexgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<TopTree::NTVertex>) );
      instance.SetNew(&new_vectorlETopTreecLcLNTVertexgR);
      instance.SetNewArray(&newArray_vectorlETopTreecLcLNTVertexgR);
      instance.SetDelete(&delete_vectorlETopTreecLcLNTVertexgR);
      instance.SetDeleteArray(&deleteArray_vectorlETopTreecLcLNTVertexgR);
      instance.SetDestructor(&destruct_vectorlETopTreecLcLNTVertexgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TopTree::NTVertex> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<TopTree::NTVertex>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETopTreecLcLNTVertexgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<TopTree::NTVertex>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETopTreecLcLNTVertexgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::NTVertex> : new vector<TopTree::NTVertex>;
   }
   static void *newArray_vectorlETopTreecLcLNTVertexgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::NTVertex>[nElements] : new vector<TopTree::NTVertex>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETopTreecLcLNTVertexgR(void *p) {
      delete ((vector<TopTree::NTVertex>*)p);
   }
   static void deleteArray_vectorlETopTreecLcLNTVertexgR(void *p) {
      delete [] ((vector<TopTree::NTVertex>*)p);
   }
   static void destruct_vectorlETopTreecLcLNTVertexgR(void *p) {
      typedef vector<TopTree::NTVertex> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TopTree::NTVertex>

namespace ROOT {
   void vectorlETopTreecLcLTopDecaysMCgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlETopTreecLcLTopDecaysMCgR_Dictionary();
   static void *new_vectorlETopTreecLcLTopDecaysMCgR(void *p = 0);
   static void *newArray_vectorlETopTreecLcLTopDecaysMCgR(Long_t size, void *p);
   static void delete_vectorlETopTreecLcLTopDecaysMCgR(void *p);
   static void deleteArray_vectorlETopTreecLcLTopDecaysMCgR(void *p);
   static void destruct_vectorlETopTreecLcLTopDecaysMCgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TopTree::TopDecaysMC>*)
   {
      vector<TopTree::TopDecaysMC> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TopTree::TopDecaysMC>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<TopTree::TopDecaysMC>", -2, "prec_stl/vector", 49,
                  typeid(vector<TopTree::TopDecaysMC>), DefineBehavior(ptr, ptr),
                  0, &vectorlETopTreecLcLTopDecaysMCgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<TopTree::TopDecaysMC>) );
      instance.SetNew(&new_vectorlETopTreecLcLTopDecaysMCgR);
      instance.SetNewArray(&newArray_vectorlETopTreecLcLTopDecaysMCgR);
      instance.SetDelete(&delete_vectorlETopTreecLcLTopDecaysMCgR);
      instance.SetDeleteArray(&deleteArray_vectorlETopTreecLcLTopDecaysMCgR);
      instance.SetDestructor(&destruct_vectorlETopTreecLcLTopDecaysMCgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TopTree::TopDecaysMC> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<TopTree::TopDecaysMC>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETopTreecLcLTopDecaysMCgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<TopTree::TopDecaysMC>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETopTreecLcLTopDecaysMCgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::TopDecaysMC> : new vector<TopTree::TopDecaysMC>;
   }
   static void *newArray_vectorlETopTreecLcLTopDecaysMCgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::TopDecaysMC>[nElements] : new vector<TopTree::TopDecaysMC>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETopTreecLcLTopDecaysMCgR(void *p) {
      delete ((vector<TopTree::TopDecaysMC>*)p);
   }
   static void deleteArray_vectorlETopTreecLcLTopDecaysMCgR(void *p) {
      delete [] ((vector<TopTree::TopDecaysMC>*)p);
   }
   static void destruct_vectorlETopTreecLcLTopDecaysMCgR(void *p) {
      typedef vector<TopTree::TopDecaysMC> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TopTree::TopDecaysMC>

namespace ROOT {
   void vectorlETopTreecLcLWDecaysMCgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlETopTreecLcLWDecaysMCgR_Dictionary();
   static void *new_vectorlETopTreecLcLWDecaysMCgR(void *p = 0);
   static void *newArray_vectorlETopTreecLcLWDecaysMCgR(Long_t size, void *p);
   static void delete_vectorlETopTreecLcLWDecaysMCgR(void *p);
   static void deleteArray_vectorlETopTreecLcLWDecaysMCgR(void *p);
   static void destruct_vectorlETopTreecLcLWDecaysMCgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TopTree::WDecaysMC>*)
   {
      vector<TopTree::WDecaysMC> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TopTree::WDecaysMC>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<TopTree::WDecaysMC>", -2, "prec_stl/vector", 49,
                  typeid(vector<TopTree::WDecaysMC>), DefineBehavior(ptr, ptr),
                  0, &vectorlETopTreecLcLWDecaysMCgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<TopTree::WDecaysMC>) );
      instance.SetNew(&new_vectorlETopTreecLcLWDecaysMCgR);
      instance.SetNewArray(&newArray_vectorlETopTreecLcLWDecaysMCgR);
      instance.SetDelete(&delete_vectorlETopTreecLcLWDecaysMCgR);
      instance.SetDeleteArray(&deleteArray_vectorlETopTreecLcLWDecaysMCgR);
      instance.SetDestructor(&destruct_vectorlETopTreecLcLWDecaysMCgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TopTree::WDecaysMC> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<TopTree::WDecaysMC>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETopTreecLcLWDecaysMCgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<TopTree::WDecaysMC>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETopTreecLcLWDecaysMCgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::WDecaysMC> : new vector<TopTree::WDecaysMC>;
   }
   static void *newArray_vectorlETopTreecLcLWDecaysMCgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::WDecaysMC>[nElements] : new vector<TopTree::WDecaysMC>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETopTreecLcLWDecaysMCgR(void *p) {
      delete ((vector<TopTree::WDecaysMC>*)p);
   }
   static void deleteArray_vectorlETopTreecLcLWDecaysMCgR(void *p) {
      delete [] ((vector<TopTree::WDecaysMC>*)p);
   }
   static void destruct_vectorlETopTreecLcLWDecaysMCgR(void *p) {
      typedef vector<TopTree::WDecaysMC> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TopTree::WDecaysMC>

namespace ROOT {
   void vectorlETopTreecLcLZDecaysMCgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlETopTreecLcLZDecaysMCgR_Dictionary();
   static void *new_vectorlETopTreecLcLZDecaysMCgR(void *p = 0);
   static void *newArray_vectorlETopTreecLcLZDecaysMCgR(Long_t size, void *p);
   static void delete_vectorlETopTreecLcLZDecaysMCgR(void *p);
   static void deleteArray_vectorlETopTreecLcLZDecaysMCgR(void *p);
   static void destruct_vectorlETopTreecLcLZDecaysMCgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TopTree::ZDecaysMC>*)
   {
      vector<TopTree::ZDecaysMC> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TopTree::ZDecaysMC>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<TopTree::ZDecaysMC>", -2, "prec_stl/vector", 49,
                  typeid(vector<TopTree::ZDecaysMC>), DefineBehavior(ptr, ptr),
                  0, &vectorlETopTreecLcLZDecaysMCgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<TopTree::ZDecaysMC>) );
      instance.SetNew(&new_vectorlETopTreecLcLZDecaysMCgR);
      instance.SetNewArray(&newArray_vectorlETopTreecLcLZDecaysMCgR);
      instance.SetDelete(&delete_vectorlETopTreecLcLZDecaysMCgR);
      instance.SetDeleteArray(&deleteArray_vectorlETopTreecLcLZDecaysMCgR);
      instance.SetDestructor(&destruct_vectorlETopTreecLcLZDecaysMCgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TopTree::ZDecaysMC> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<TopTree::ZDecaysMC>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETopTreecLcLZDecaysMCgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<TopTree::ZDecaysMC>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETopTreecLcLZDecaysMCgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::ZDecaysMC> : new vector<TopTree::ZDecaysMC>;
   }
   static void *newArray_vectorlETopTreecLcLZDecaysMCgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TopTree::ZDecaysMC>[nElements] : new vector<TopTree::ZDecaysMC>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETopTreecLcLZDecaysMCgR(void *p) {
      delete ((vector<TopTree::ZDecaysMC>*)p);
   }
   static void deleteArray_vectorlETopTreecLcLZDecaysMCgR(void *p) {
      delete [] ((vector<TopTree::ZDecaysMC>*)p);
   }
   static void destruct_vectorlETopTreecLcLZDecaysMCgR(void *p) {
      typedef vector<TopTree::ZDecaysMC> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TopTree::ZDecaysMC>

namespace ROOT {
   void vectorlEfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEfloatgR_Dictionary();
   static void *new_vectorlEfloatgR(void *p = 0);
   static void *newArray_vectorlEfloatgR(Long_t size, void *p);
   static void delete_vectorlEfloatgR(void *p);
   static void deleteArray_vectorlEfloatgR(void *p);
   static void destruct_vectorlEfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<float>*)
   {
      vector<float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<float>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<float>", -2, "vector.dll", 0,
                  typeid(vector<float>), DefineBehavior(ptr, ptr),
                  0, &vectorlEfloatgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<float>) );
      instance.SetNew(&new_vectorlEfloatgR);
      instance.SetNewArray(&newArray_vectorlEfloatgR);
      instance.SetDelete(&delete_vectorlEfloatgR);
      instance.SetDeleteArray(&deleteArray_vectorlEfloatgR);
      instance.SetDestructor(&destruct_vectorlEfloatgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<float> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEfloatgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<float>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEfloatgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<float> : new vector<float>;
   }
   static void *newArray_vectorlEfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<float>[nElements] : new vector<float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEfloatgR(void *p) {
      delete ((vector<float>*)p);
   }
   static void deleteArray_vectorlEfloatgR(void *p) {
      delete [] ((vector<float>*)p);
   }
   static void destruct_vectorlEfloatgR(void *p) {
      typedef vector<float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<float>

namespace ROOT {
   void vectorlEpairlEstringcOboolgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEpairlEstringcOboolgRsPgR_Dictionary();
   static void *new_vectorlEpairlEstringcOboolgRsPgR(void *p = 0);
   static void *newArray_vectorlEpairlEstringcOboolgRsPgR(Long_t size, void *p);
   static void delete_vectorlEpairlEstringcOboolgRsPgR(void *p);
   static void deleteArray_vectorlEpairlEstringcOboolgRsPgR(void *p);
   static void destruct_vectorlEpairlEstringcOboolgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pair<string,bool> >*)
   {
      vector<pair<string,bool> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pair<string,bool> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<pair<string,bool> >", -2, "prec_stl/vector", 49,
                  typeid(vector<pair<string,bool> >), DefineBehavior(ptr, ptr),
                  0, &vectorlEpairlEstringcOboolgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<pair<string,bool> >) );
      instance.SetNew(&new_vectorlEpairlEstringcOboolgRsPgR);
      instance.SetNewArray(&newArray_vectorlEpairlEstringcOboolgRsPgR);
      instance.SetDelete(&delete_vectorlEpairlEstringcOboolgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpairlEstringcOboolgRsPgR);
      instance.SetDestructor(&destruct_vectorlEpairlEstringcOboolgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pair<string,bool> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pair<string,bool> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEpairlEstringcOboolgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<pair<string,bool> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpairlEstringcOboolgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pair<string,bool> > : new vector<pair<string,bool> >;
   }
   static void *newArray_vectorlEpairlEstringcOboolgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pair<string,bool> >[nElements] : new vector<pair<string,bool> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpairlEstringcOboolgRsPgR(void *p) {
      delete ((vector<pair<string,bool> >*)p);
   }
   static void deleteArray_vectorlEpairlEstringcOboolgRsPgR(void *p) {
      delete [] ((vector<pair<string,bool> >*)p);
   }
   static void destruct_vectorlEpairlEstringcOboolgRsPgR(void *p) {
      typedef vector<pair<string,bool> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pair<string,bool> >

namespace ROOT {
   void vectorlEpairlEstringcOfloatgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEpairlEstringcOfloatgRsPgR_Dictionary();
   static void *new_vectorlEpairlEstringcOfloatgRsPgR(void *p = 0);
   static void *newArray_vectorlEpairlEstringcOfloatgRsPgR(Long_t size, void *p);
   static void delete_vectorlEpairlEstringcOfloatgRsPgR(void *p);
   static void deleteArray_vectorlEpairlEstringcOfloatgRsPgR(void *p);
   static void destruct_vectorlEpairlEstringcOfloatgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pair<string,float> >*)
   {
      vector<pair<string,float> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pair<string,float> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<pair<string,float> >", -2, "prec_stl/vector", 49,
                  typeid(vector<pair<string,float> >), DefineBehavior(ptr, ptr),
                  0, &vectorlEpairlEstringcOfloatgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<pair<string,float> >) );
      instance.SetNew(&new_vectorlEpairlEstringcOfloatgRsPgR);
      instance.SetNewArray(&newArray_vectorlEpairlEstringcOfloatgRsPgR);
      instance.SetDelete(&delete_vectorlEpairlEstringcOfloatgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpairlEstringcOfloatgRsPgR);
      instance.SetDestructor(&destruct_vectorlEpairlEstringcOfloatgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pair<string,float> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pair<string,float> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEpairlEstringcOfloatgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<pair<string,float> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpairlEstringcOfloatgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pair<string,float> > : new vector<pair<string,float> >;
   }
   static void *newArray_vectorlEpairlEstringcOfloatgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pair<string,float> >[nElements] : new vector<pair<string,float> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpairlEstringcOfloatgRsPgR(void *p) {
      delete ((vector<pair<string,float> >*)p);
   }
   static void deleteArray_vectorlEpairlEstringcOfloatgRsPgR(void *p) {
      delete [] ((vector<pair<string,float> >*)p);
   }
   static void destruct_vectorlEpairlEstringcOfloatgRsPgR(void *p) {
      typedef vector<pair<string,float> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pair<string,float> >

namespace ROOT {
   void vectorlEpairlEstringcOintgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEpairlEstringcOintgRsPgR_Dictionary();
   static void *new_vectorlEpairlEstringcOintgRsPgR(void *p = 0);
   static void *newArray_vectorlEpairlEstringcOintgRsPgR(Long_t size, void *p);
   static void delete_vectorlEpairlEstringcOintgRsPgR(void *p);
   static void deleteArray_vectorlEpairlEstringcOintgRsPgR(void *p);
   static void destruct_vectorlEpairlEstringcOintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pair<string,int> >*)
   {
      vector<pair<string,int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pair<string,int> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<pair<string,int> >", -2, "prec_stl/vector", 49,
                  typeid(vector<pair<string,int> >), DefineBehavior(ptr, ptr),
                  0, &vectorlEpairlEstringcOintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<pair<string,int> >) );
      instance.SetNew(&new_vectorlEpairlEstringcOintgRsPgR);
      instance.SetNewArray(&newArray_vectorlEpairlEstringcOintgRsPgR);
      instance.SetDelete(&delete_vectorlEpairlEstringcOintgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpairlEstringcOintgRsPgR);
      instance.SetDestructor(&destruct_vectorlEpairlEstringcOintgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pair<string,int> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pair<string,int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEpairlEstringcOintgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<pair<string,int> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpairlEstringcOintgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pair<string,int> > : new vector<pair<string,int> >;
   }
   static void *newArray_vectorlEpairlEstringcOintgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pair<string,int> >[nElements] : new vector<pair<string,int> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpairlEstringcOintgRsPgR(void *p) {
      delete ((vector<pair<string,int> >*)p);
   }
   static void deleteArray_vectorlEpairlEstringcOintgRsPgR(void *p) {
      delete [] ((vector<pair<string,int> >*)p);
   }
   static void destruct_vectorlEpairlEstringcOintgRsPgR(void *p) {
      typedef vector<pair<string,int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pair<string,int> >

namespace ROOT {
   void vectorlEvectorlETLorentzVectorgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEvectorlETLorentzVectorgRsPgR_Dictionary();
   static void *new_vectorlEvectorlETLorentzVectorgRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlETLorentzVectorgRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlETLorentzVectorgRsPgR(void *p);
   static void deleteArray_vectorlEvectorlETLorentzVectorgRsPgR(void *p);
   static void destruct_vectorlEvectorlETLorentzVectorgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<TLorentzVector> >*)
   {
      vector<vector<TLorentzVector> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<TLorentzVector> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<TLorentzVector> >", -2, "prec_stl/vector", 49,
                  typeid(vector<vector<TLorentzVector> >), DefineBehavior(ptr, ptr),
                  0, &vectorlEvectorlETLorentzVectorgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<vector<TLorentzVector> >) );
      instance.SetNew(&new_vectorlEvectorlETLorentzVectorgRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlETLorentzVectorgRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlETLorentzVectorgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlETLorentzVectorgRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlETLorentzVectorgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<vector<TLorentzVector> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<TLorentzVector> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEvectorlETLorentzVectorgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<vector<TLorentzVector> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEvectorlETLorentzVectorgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<TLorentzVector> > : new vector<vector<TLorentzVector> >;
   }
   static void *newArray_vectorlEvectorlETLorentzVectorgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<TLorentzVector> >[nElements] : new vector<vector<TLorentzVector> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlETLorentzVectorgRsPgR(void *p) {
      delete ((vector<vector<TLorentzVector> >*)p);
   }
   static void deleteArray_vectorlEvectorlETLorentzVectorgRsPgR(void *p) {
      delete [] ((vector<vector<TLorentzVector> >*)p);
   }
   static void destruct_vectorlEvectorlETLorentzVectorgRsPgR(void *p) {
      typedef vector<vector<TLorentzVector> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<vector<TLorentzVector> >

/********************************************************
* Dict.cc
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && __GNUC__ >= 4 && ((__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >= 1) || (__GNUC_MINOR__ >= 3))
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtableDict();

extern "C" void G__set_cpp_environmentDict() {
  G__add_compiledheader("TObject.h");
  G__add_compiledheader("TMemberInspector.h");
  G__add_compiledheader("../interface/NTCollection.h");
  G__add_compiledheader("../interface/NTElectron.h");
  G__add_compiledheader("../interface/NTEvent.h");
  G__add_compiledheader("../interface/NTJet.h");
  G__add_compiledheader("../interface/NTJetMet.h");
  G__add_compiledheader("../interface/NTLepton.h");
  G__add_compiledheader("../interface/NTMET.h");
  G__add_compiledheader("../interface/NTMuon.h");
  G__add_compiledheader("../interface/NTPU.h");
  G__add_compiledheader("../interface/NTPhoton.h");
  G__add_compiledheader("../interface/NTSampleInfo.h");
  G__add_compiledheader("../interface/NTTau.h");
  G__add_compiledheader("../interface/NTTrack.h");
  G__add_compiledheader("../interface/NTVertex.h");
  G__cpp_reset_tagtableDict();
}
#include <new>
extern "C" int G__cpp_dllrevDict() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* TopTree::NTLepton */
static int G__Dict_215_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTLepton* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTLepton[n];
     } else {
       p = new((void*) gvp) TopTree::NTLepton[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTLepton;
     } else {
       p = new((void*) gvp) TopTree::NTLepton;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTLepton));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_215_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTLepton*) G__getstructoffset())->Reset();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_215_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((TopTree::NTLepton*) G__getstructoffset())->RelIso03());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_215_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((TopTree::NTLepton*) G__getstructoffset())->RelIso03PF());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_215_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((TopTree::NTLepton*) G__getstructoffset())->RelIso03RhoCorrected((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_215_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((TopTree::NTLepton*) G__getstructoffset())->RelIso03PFRhoCorrected((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_215_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((TopTree::NTLepton*) G__getstructoffset())->RelIso03NeutralRhoCorrected((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_215_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((TopTree::NTLepton*) G__getstructoffset())->RelIso03PFNeutralRhoCorrected((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_215_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TopTree::NTLepton*) G__getstructoffset())->PrintInfo(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((TopTree::NTLepton*) G__getstructoffset())->PrintInfo();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_215_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((TopTree::NTLepton*) G__getstructoffset())->PrintP4(*((TLorentzVector*) G__int(libp->para[0])), *(ostream*) libp->para[1].ref);
      G__setnull(result7);
      break;
   case 1:
      ((TopTree::NTLepton*) G__getstructoffset())->PrintP4(*((TLorentzVector*) G__int(libp->para[0])));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_215_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((TopTree::NTLepton*) G__getstructoffset())->PrintP3(*((TVector3*) G__int(libp->para[0])), *(ostream*) libp->para[1].ref);
      G__setnull(result7);
      break;
   case 1:
      ((TopTree::NTLepton*) G__getstructoffset())->PrintP3(*((TVector3*) G__int(libp->para[0])));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Dict_215_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TopTree::NTLepton* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TopTree::NTLepton(*(TopTree::NTLepton*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTLepton));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TopTree::NTLepton G__TTopTreecLcLNTLepton;
static int G__Dict_215_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TopTree::NTLepton*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TopTree::NTLepton*) (soff+(sizeof(TopTree::NTLepton)*i)))->~G__TTopTreecLcLNTLepton();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TopTree::NTLepton*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TopTree::NTLepton*) (soff))->~G__TTopTreecLcLNTLepton();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Dict_215_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTLepton* dest = (TopTree::NTLepton*) G__getstructoffset();
   *dest = *(TopTree::NTLepton*) libp->para[0].ref;
   const TopTree::NTLepton& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TopTree::NTElectron */
static int G__Dict_216_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTElectron* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTElectron[n];
     } else {
       p = new((void*) gvp) TopTree::NTElectron[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTElectron;
     } else {
       p = new((void*) gvp) TopTree::NTElectron;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTElectron));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_216_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTElectron*) G__getstructoffset())->Reset();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_216_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TopTree::NTElectron*) G__getstructoffset())->isNotConv((int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_216_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TopTree::NTElectron*) G__getstructoffset())->hadId((int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_216_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TopTree::NTElectron*) G__getstructoffset())->Dump(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((TopTree::NTElectron*) G__getstructoffset())->Dump();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_216_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         TopTree::NTElectron* pobj;
         TopTree::NTElectron xobj = ((TopTree::NTElectron*) G__getstructoffset())->GetNTElectron();
         pobj = new TopTree::NTElectron(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_216_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TopTree::NTElectron*) G__getstructoffset())->GetNTElectronPointer());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_216_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((TopTree::NTElectron*) G__getstructoffset())->CombinedRelIso03());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Dict_216_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TopTree::NTElectron* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TopTree::NTElectron(*(TopTree::NTElectron*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTElectron));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TopTree::NTElectron G__TTopTreecLcLNTElectron;
static int G__Dict_216_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TopTree::NTElectron*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TopTree::NTElectron*) (soff+(sizeof(TopTree::NTElectron)*i)))->~G__TTopTreecLcLNTElectron();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TopTree::NTElectron*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TopTree::NTElectron*) (soff))->~G__TTopTreecLcLNTElectron();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Dict_216_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTElectron* dest = (TopTree::NTElectron*) G__getstructoffset();
   *dest = *(TopTree::NTElectron*) libp->para[0].ref;
   const TopTree::NTElectron& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TopTree::NTJet */
static int G__Dict_217_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTJet* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTJet[n];
     } else {
       p = new((void*) gvp) TopTree::NTJet[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTJet;
     } else {
       p = new((void*) gvp) TopTree::NTJet;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTJet));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_217_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTJet*) G__getstructoffset())->Reset();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_217_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TopTree::NTJet*) G__getstructoffset())->Dump(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((TopTree::NTJet*) G__getstructoffset())->Dump();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_217_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((TopTree::NTJet*) G__getstructoffset())->PrintP4(*((TLorentzVector*) G__int(libp->para[0])), *(ostream*) libp->para[1].ref);
      G__setnull(result7);
      break;
   case 1:
      ((TopTree::NTJet*) G__getstructoffset())->PrintP4(*((TLorentzVector*) G__int(libp->para[0])));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_217_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         TopTree::NTJet* pobj;
         TopTree::NTJet xobj = ((TopTree::NTJet*) G__getstructoffset())->GetNTJet();
         pobj = new TopTree::NTJet(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_217_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TopTree::NTJet*) G__getstructoffset())->GetNTJetPointer());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_217_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const TopTree::NTJet*) G__getstructoffset())->GetDiscri(*((string*) G__int(libp->para[0]))));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Dict_217_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TopTree::NTJet* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TopTree::NTJet(*(TopTree::NTJet*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTJet));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TopTree::NTJet G__TTopTreecLcLNTJet;
static int G__Dict_217_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TopTree::NTJet*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TopTree::NTJet*) (soff+(sizeof(TopTree::NTJet)*i)))->~G__TTopTreecLcLNTJet();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TopTree::NTJet*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TopTree::NTJet*) (soff))->~G__TTopTreecLcLNTJet();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Dict_217_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTJet* dest = (TopTree::NTJet*) G__getstructoffset();
   *dest = *(TopTree::NTJet*) libp->para[0].ref;
   const TopTree::NTJet& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TopTree::NTPhoton */
static int G__Dict_223_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTPhoton* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTPhoton[n];
     } else {
       p = new((void*) gvp) TopTree::NTPhoton[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTPhoton;
     } else {
       p = new((void*) gvp) TopTree::NTPhoton;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTPhoton));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_223_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTPhoton*) G__getstructoffset())->Reset();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_223_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TopTree::NTPhoton*) G__getstructoffset())->PrintInfo(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((TopTree::NTPhoton*) G__getstructoffset())->PrintInfo();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_223_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((TopTree::NTPhoton*) G__getstructoffset())->PrintP4(*((TLorentzVector*) G__int(libp->para[0])), *(ostream*) libp->para[1].ref);
      G__setnull(result7);
      break;
   case 1:
      ((TopTree::NTPhoton*) G__getstructoffset())->PrintP4(*((TLorentzVector*) G__int(libp->para[0])));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_223_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((TopTree::NTPhoton*) G__getstructoffset())->PrintP3(*((TVector3*) G__int(libp->para[0])), *(ostream*) libp->para[1].ref);
      G__setnull(result7);
      break;
   case 1:
      ((TopTree::NTPhoton*) G__getstructoffset())->PrintP3(*((TVector3*) G__int(libp->para[0])));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Dict_223_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TopTree::NTPhoton* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TopTree::NTPhoton(*(TopTree::NTPhoton*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTPhoton));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TopTree::NTPhoton G__TTopTreecLcLNTPhoton;
static int G__Dict_223_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TopTree::NTPhoton*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TopTree::NTPhoton*) (soff+(sizeof(TopTree::NTPhoton)*i)))->~G__TTopTreecLcLNTPhoton();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TopTree::NTPhoton*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TopTree::NTPhoton*) (soff))->~G__TTopTreecLcLNTPhoton();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Dict_223_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTPhoton* dest = (TopTree::NTPhoton*) G__getstructoffset();
   *dest = *(TopTree::NTPhoton*) libp->para[0].ref;
   const TopTree::NTPhoton& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TopTree::NTMuon */
static int G__Dict_224_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTMuon* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTMuon[n];
     } else {
       p = new((void*) gvp) TopTree::NTMuon[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTMuon;
     } else {
       p = new((void*) gvp) TopTree::NTMuon;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMuon));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_224_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTMuon*) G__getstructoffset())->Reset();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_224_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TopTree::NTMuon*) G__getstructoffset())->Dump(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((TopTree::NTMuon*) G__getstructoffset())->Dump();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_224_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         TopTree::NTMuon* pobj;
         TopTree::NTMuon xobj = ((TopTree::NTMuon*) G__getstructoffset())->GetNTMuon();
         pobj = new TopTree::NTMuon(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_224_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TopTree::NTMuon*) G__getstructoffset())->GetNTMuonPointer());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Dict_224_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TopTree::NTMuon* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TopTree::NTMuon(*(TopTree::NTMuon*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMuon));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TopTree::NTMuon G__TTopTreecLcLNTMuon;
static int G__Dict_224_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TopTree::NTMuon*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TopTree::NTMuon*) (soff+(sizeof(TopTree::NTMuon)*i)))->~G__TTopTreecLcLNTMuon();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TopTree::NTMuon*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TopTree::NTMuon*) (soff))->~G__TTopTreecLcLNTMuon();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Dict_224_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTMuon* dest = (TopTree::NTMuon*) G__getstructoffset();
   *dest = *(TopTree::NTMuon*) libp->para[0].ref;
   const TopTree::NTMuon& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TopTree::NTTau */
static int G__Dict_225_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTTau* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTTau[n];
     } else {
       p = new((void*) gvp) TopTree::NTTau[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTTau;
     } else {
       p = new((void*) gvp) TopTree::NTTau;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTau));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_225_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTTau*) G__getstructoffset())->Reset();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_225_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TopTree::NTTau*) G__getstructoffset())->Dump(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((TopTree::NTTau*) G__getstructoffset())->Dump();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_225_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         TopTree::NTTau* pobj;
         TopTree::NTTau xobj = ((TopTree::NTTau*) G__getstructoffset())->GetNTTau();
         pobj = new TopTree::NTTau(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_225_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TopTree::NTTau*) G__getstructoffset())->GetNTTauPointer());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_225_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TopTree::NTTau*) G__getstructoffset())->GetDiscriminator(*((string*) G__int(libp->para[0]))));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Dict_225_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TopTree::NTTau* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TopTree::NTTau(*(TopTree::NTTau*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTau));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TopTree::NTTau G__TTopTreecLcLNTTau;
static int G__Dict_225_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TopTree::NTTau*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TopTree::NTTau*) (soff+(sizeof(TopTree::NTTau)*i)))->~G__TTopTreecLcLNTTau();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TopTree::NTTau*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TopTree::NTTau*) (soff))->~G__TTopTreecLcLNTTau();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Dict_225_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTTau* dest = (TopTree::NTTau*) G__getstructoffset();
   *dest = *(TopTree::NTTau*) libp->para[0].ref;
   const TopTree::NTTau& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TopTree::NTMET */
static int G__Dict_226_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTMET* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTMET[n];
     } else {
       p = new((void*) gvp) TopTree::NTMET[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTMET;
     } else {
       p = new((void*) gvp) TopTree::NTMET;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMET));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_226_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTMET*) G__getstructoffset())->Reset();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_226_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TopTree::NTMET*) G__getstructoffset())->Dump(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((TopTree::NTMET*) G__getstructoffset())->Dump();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_226_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((TopTree::NTMET*) G__getstructoffset())->PrintP4(*((TLorentzVector*) G__int(libp->para[0])), *(ostream*) libp->para[1].ref);
      G__setnull(result7);
      break;
   case 1:
      ((TopTree::NTMET*) G__getstructoffset())->PrintP4(*((TLorentzVector*) G__int(libp->para[0])));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_226_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         TopTree::NTMET* pobj;
         TopTree::NTMET xobj = ((TopTree::NTMET*) G__getstructoffset())->GetNTMET();
         pobj = new TopTree::NTMET(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_226_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TopTree::NTMET*) G__getstructoffset())->GetNTMETPointer());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Dict_226_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TopTree::NTMET* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TopTree::NTMET(*(TopTree::NTMET*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMET));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TopTree::NTMET G__TTopTreecLcLNTMET;
static int G__Dict_226_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TopTree::NTMET*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TopTree::NTMET*) (soff+(sizeof(TopTree::NTMET)*i)))->~G__TTopTreecLcLNTMET();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TopTree::NTMET*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TopTree::NTMET*) (soff))->~G__TTopTreecLcLNTMET();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Dict_226_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTMET* dest = (TopTree::NTMET*) G__getstructoffset();
   *dest = *(TopTree::NTMET*) libp->para[0].ref;
   const TopTree::NTMET& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TopTree::NTJetMet */
static int G__Dict_227_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTJetMet* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTJetMet[n];
     } else {
       p = new((void*) gvp) TopTree::NTJetMet[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTJetMet;
     } else {
       p = new((void*) gvp) TopTree::NTJetMet;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTJetMet));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_227_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTJetMet*) G__getstructoffset())->Reset();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Dict_227_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TopTree::NTJetMet* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TopTree::NTJetMet(*(TopTree::NTJetMet*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTJetMet));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TopTree::NTJetMet G__TTopTreecLcLNTJetMet;
static int G__Dict_227_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TopTree::NTJetMet*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TopTree::NTJetMet*) (soff+(sizeof(TopTree::NTJetMet)*i)))->~G__TTopTreecLcLNTJetMet();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TopTree::NTJetMet*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TopTree::NTJetMet*) (soff))->~G__TTopTreecLcLNTJetMet();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Dict_227_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTJetMet* dest = (TopTree::NTJetMet*) G__getstructoffset();
   *dest = *(TopTree::NTJetMet*) libp->para[0].ref;
   const TopTree::NTJetMet& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TopTree::NTCollection<TopTree::NTJet> */
static int G__Dict_228_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTCollection<TopTree::NTJet>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTCollection<TopTree::NTJet>[n];
     } else {
       p = new((void*) gvp) TopTree::NTCollection<TopTree::NTJet>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTCollection<TopTree::NTJet>;
     } else {
       p = new((void*) gvp) TopTree::NTCollection<TopTree::NTJet>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_228_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTCollection<TopTree::NTJet>*) G__getstructoffset())->Reset();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_228_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TopTree::NTCollection<TopTree::NTJet>*) G__getstructoffset())->Dump(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((TopTree::NTCollection<TopTree::NTJet>*) G__getstructoffset())->Dump();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_228_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TopTree::NTCollection<TopTree::NTJet>*) G__getstructoffset())->PrintListOfObjects(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((TopTree::NTCollection<TopTree::NTJet>*) G__getstructoffset())->PrintListOfObjects();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Dict_228_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TopTree::NTCollection<TopTree::NTJet>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TopTree::NTCollection<TopTree::NTJet>(*(TopTree::NTCollection<TopTree::NTJet>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TopTree::NTCollection<TopTree::NTJet> G__TTopTreecLcLNTCollectionlETopTreecLcLNTJetgR;
static int G__Dict_228_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TopTree::NTCollection<TopTree::NTJet>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TopTree::NTCollection<TopTree::NTJet>*) (soff+(sizeof(TopTree::NTCollection<TopTree::NTJet>)*i)))->~G__TTopTreecLcLNTCollectionlETopTreecLcLNTJetgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TopTree::NTCollection<TopTree::NTJet>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TopTree::NTCollection<TopTree::NTJet>*) (soff))->~G__TTopTreecLcLNTCollectionlETopTreecLcLNTJetgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Dict_228_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTCollection<TopTree::NTJet>* dest = (TopTree::NTCollection<TopTree::NTJet>*) G__getstructoffset();
   *dest = *(TopTree::NTCollection<TopTree::NTJet>*) libp->para[0].ref;
   const TopTree::NTCollection<TopTree::NTJet>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TopTree::NTVertex */
static int G__Dict_233_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTVertex* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTVertex[n];
     } else {
       p = new((void*) gvp) TopTree::NTVertex[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTVertex;
     } else {
       p = new((void*) gvp) TopTree::NTVertex;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTVertex));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_233_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTVertex*) G__getstructoffset())->Reset();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_233_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TopTree::NTVertex*) G__getstructoffset())->Dump(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((TopTree::NTVertex*) G__getstructoffset())->Dump();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_233_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((TopTree::NTVertex*) G__getstructoffset())->PrintP4(*((TLorentzVector*) G__int(libp->para[0])), *(ostream*) libp->para[1].ref);
      G__setnull(result7);
      break;
   case 1:
      ((TopTree::NTVertex*) G__getstructoffset())->PrintP4(*((TLorentzVector*) G__int(libp->para[0])));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_233_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((TopTree::NTVertex*) G__getstructoffset())->PrintP3(*((TVector3*) G__int(libp->para[0])), *(ostream*) libp->para[1].ref);
      G__setnull(result7);
      break;
   case 1:
      ((TopTree::NTVertex*) G__getstructoffset())->PrintP3(*((TVector3*) G__int(libp->para[0])));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_233_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         TopTree::NTVertex* pobj;
         TopTree::NTVertex xobj = ((TopTree::NTVertex*) G__getstructoffset())->GetNTVertex();
         pobj = new TopTree::NTVertex(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_233_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TopTree::NTVertex*) G__getstructoffset())->GetNTVertexPointer());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Dict_233_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TopTree::NTVertex* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TopTree::NTVertex(*(TopTree::NTVertex*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTVertex));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TopTree::NTVertex G__TTopTreecLcLNTVertex;
static int G__Dict_233_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TopTree::NTVertex*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TopTree::NTVertex*) (soff+(sizeof(TopTree::NTVertex)*i)))->~G__TTopTreecLcLNTVertex();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TopTree::NTVertex*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TopTree::NTVertex*) (soff))->~G__TTopTreecLcLNTVertex();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Dict_233_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTVertex* dest = (TopTree::NTVertex*) G__getstructoffset();
   *dest = *(TopTree::NTVertex*) libp->para[0].ref;
   const TopTree::NTVertex& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TopTree::NTTrack */
static int G__Dict_234_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTTrack* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTTrack[n];
     } else {
       p = new((void*) gvp) TopTree::NTTrack[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTTrack;
     } else {
       p = new((void*) gvp) TopTree::NTTrack;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTrack));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_234_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTTrack*) G__getstructoffset())->Reset();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_234_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TopTree::NTTrack*) G__getstructoffset())->Dump(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((TopTree::NTTrack*) G__getstructoffset())->Dump();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_234_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((TopTree::NTTrack*) G__getstructoffset())->PrintP4(*((TLorentzVector*) G__int(libp->para[0])), *(ostream*) libp->para[1].ref);
      G__setnull(result7);
      break;
   case 1:
      ((TopTree::NTTrack*) G__getstructoffset())->PrintP4(*((TLorentzVector*) G__int(libp->para[0])));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_234_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         TopTree::NTTrack* pobj;
         TopTree::NTTrack xobj = ((TopTree::NTTrack*) G__getstructoffset())->GetNTTrack();
         pobj = new TopTree::NTTrack(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_234_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TopTree::NTTrack*) G__getstructoffset())->GetNTTrackPointer());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Dict_234_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TopTree::NTTrack* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TopTree::NTTrack(*(TopTree::NTTrack*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTrack));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TopTree::NTTrack G__TTopTreecLcLNTTrack;
static int G__Dict_234_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TopTree::NTTrack*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TopTree::NTTrack*) (soff+(sizeof(TopTree::NTTrack)*i)))->~G__TTopTreecLcLNTTrack();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TopTree::NTTrack*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TopTree::NTTrack*) (soff))->~G__TTopTreecLcLNTTrack();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Dict_234_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTTrack* dest = (TopTree::NTTrack*) G__getstructoffset();
   *dest = *(TopTree::NTTrack*) libp->para[0].ref;
   const TopTree::NTTrack& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TopTree::WDecaysMC */
static int G__Dict_235_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::WDecaysMC* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::WDecaysMC[n];
     } else {
       p = new((void*) gvp) TopTree::WDecaysMC[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::WDecaysMC;
     } else {
       p = new((void*) gvp) TopTree::WDecaysMC;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLWDecaysMC));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Dict_235_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TopTree::WDecaysMC* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TopTree::WDecaysMC(*(TopTree::WDecaysMC*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLWDecaysMC));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TopTree::WDecaysMC G__TTopTreecLcLWDecaysMC;
static int G__Dict_235_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TopTree::WDecaysMC*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TopTree::WDecaysMC*) (soff+(sizeof(TopTree::WDecaysMC)*i)))->~G__TTopTreecLcLWDecaysMC();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TopTree::WDecaysMC*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TopTree::WDecaysMC*) (soff))->~G__TTopTreecLcLWDecaysMC();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Dict_235_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::WDecaysMC* dest = (TopTree::WDecaysMC*) G__getstructoffset();
   *dest = *(TopTree::WDecaysMC*) libp->para[0].ref;
   const TopTree::WDecaysMC& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TopTree::ZDecaysMC */
static int G__Dict_236_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::ZDecaysMC* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::ZDecaysMC[n];
     } else {
       p = new((void*) gvp) TopTree::ZDecaysMC[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::ZDecaysMC;
     } else {
       p = new((void*) gvp) TopTree::ZDecaysMC;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLZDecaysMC));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Dict_236_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TopTree::ZDecaysMC* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TopTree::ZDecaysMC(*(TopTree::ZDecaysMC*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLZDecaysMC));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TopTree::ZDecaysMC G__TTopTreecLcLZDecaysMC;
static int G__Dict_236_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TopTree::ZDecaysMC*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TopTree::ZDecaysMC*) (soff+(sizeof(TopTree::ZDecaysMC)*i)))->~G__TTopTreecLcLZDecaysMC();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TopTree::ZDecaysMC*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TopTree::ZDecaysMC*) (soff))->~G__TTopTreecLcLZDecaysMC();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Dict_236_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::ZDecaysMC* dest = (TopTree::ZDecaysMC*) G__getstructoffset();
   *dest = *(TopTree::ZDecaysMC*) libp->para[0].ref;
   const TopTree::ZDecaysMC& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TopTree::TopDecaysMC */
static int G__Dict_237_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::TopDecaysMC* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::TopDecaysMC[n];
     } else {
       p = new((void*) gvp) TopTree::TopDecaysMC[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::TopDecaysMC;
     } else {
       p = new((void*) gvp) TopTree::TopDecaysMC;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLTopDecaysMC));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Dict_237_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TopTree::TopDecaysMC* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TopTree::TopDecaysMC(*(TopTree::TopDecaysMC*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLTopDecaysMC));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TopTree::TopDecaysMC G__TTopTreecLcLTopDecaysMC;
static int G__Dict_237_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TopTree::TopDecaysMC*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TopTree::TopDecaysMC*) (soff+(sizeof(TopTree::TopDecaysMC)*i)))->~G__TTopTreecLcLTopDecaysMC();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TopTree::TopDecaysMC*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TopTree::TopDecaysMC*) (soff))->~G__TTopTreecLcLTopDecaysMC();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Dict_237_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::TopDecaysMC* dest = (TopTree::TopDecaysMC*) G__getstructoffset();
   *dest = *(TopTree::TopDecaysMC*) libp->para[0].ref;
   const TopTree::TopDecaysMC& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TopTree::NTPU */
static int G__Dict_238_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTPU* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTPU[n];
     } else {
       p = new((void*) gvp) TopTree::NTPU[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTPU;
     } else {
       p = new((void*) gvp) TopTree::NTPU;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTPU));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_238_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTPU*) G__getstructoffset())->Reset();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_238_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TopTree::NTPU*) G__getstructoffset())->Dump(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((TopTree::NTPU*) G__getstructoffset())->Dump();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_238_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         TopTree::NTPU* pobj;
         TopTree::NTPU xobj = ((TopTree::NTPU*) G__getstructoffset())->GetNTPU();
         pobj = new TopTree::NTPU(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_238_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TopTree::NTPU*) G__getstructoffset())->GetNTPUPointer());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Dict_238_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TopTree::NTPU* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TopTree::NTPU(*(TopTree::NTPU*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTPU));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TopTree::NTPU G__TTopTreecLcLNTPU;
static int G__Dict_238_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TopTree::NTPU*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TopTree::NTPU*) (soff+(sizeof(TopTree::NTPU)*i)))->~G__TTopTreecLcLNTPU();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TopTree::NTPU*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TopTree::NTPU*) (soff))->~G__TTopTreecLcLNTPU();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Dict_238_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTPU* dest = (TopTree::NTPU*) G__getstructoffset();
   *dest = *(TopTree::NTPU*) libp->para[0].ref;
   const TopTree::NTPU& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TopTree::NTEvent */
static int G__Dict_239_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTEvent* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTEvent[n];
     } else {
       p = new((void*) gvp) TopTree::NTEvent[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTEvent;
     } else {
       p = new((void*) gvp) TopTree::NTEvent;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTEvent));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTEvent*) G__getstructoffset())->Reset();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TopTree::NTEvent*) G__getstructoffset())->Print(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((TopTree::NTEvent*) G__getstructoffset())->Print();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TopTree::NTEvent*) G__getstructoffset())->PrintTriggerPassed(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((TopTree::NTEvent*) G__getstructoffset())->PrintTriggerPassed();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTEvent*) G__getstructoffset())->PrintTriggerList(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TopTree::NTEvent*) G__getstructoffset())->TriggerPassed(*((string*) G__int(libp->para[0]))));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TopTree::NTEvent*) G__getstructoffset())->TriggerStored(*((string*) G__int(libp->para[0]))));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TopTree::NTEvent*) G__getstructoffset())->NewElectron());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TopTree::NTEvent*) G__getstructoffset())->NewPhoton());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TopTree::NTEvent*) G__getstructoffset())->NewMuon());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TopTree::NTEvent*) G__getstructoffset())->NewTauColl());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TopTree::NTEvent*) G__getstructoffset())->NewVertex());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TopTree::NTEvent*) G__getstructoffset())->NewJetMet());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TopTree::NTEvent*) G__getstructoffset())->NewTrack());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TopTree::NTEvent*) G__getstructoffset())->NewPU());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTEvent*) G__getstructoffset())->NewElectron(*(TopTree::NTElectron*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTEvent*) G__getstructoffset())->NewPhoton(*(TopTree::NTPhoton*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTEvent*) G__getstructoffset())->NewMuon(*(TopTree::NTMuon*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTEvent*) G__getstructoffset())->NewTauColl(*(TopTree::NTCollection<TopTree::NTTau>*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTEvent*) G__getstructoffset())->NewVertex(*(TopTree::NTVertex*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTEvent*) G__getstructoffset())->NewTrack(*(TopTree::NTTrack*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTEvent*) G__getstructoffset())->NewJetMet(*(TopTree::NTJetMet*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_239_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTEvent*) G__getstructoffset())->NewPU(*(TopTree::NTPU*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Dict_239_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TopTree::NTEvent* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TopTree::NTEvent(*(TopTree::NTEvent*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTEvent));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TopTree::NTEvent G__TTopTreecLcLNTEvent;
static int G__Dict_239_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TopTree::NTEvent*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TopTree::NTEvent*) (soff+(sizeof(TopTree::NTEvent)*i)))->~G__TTopTreecLcLNTEvent();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TopTree::NTEvent*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TopTree::NTEvent*) (soff))->~G__TTopTreecLcLNTEvent();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TopTree::NTCollection<TopTree::NTTau> */
static int G__Dict_240_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTCollection<TopTree::NTTau>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTCollection<TopTree::NTTau>[n];
     } else {
       p = new((void*) gvp) TopTree::NTCollection<TopTree::NTTau>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TopTree::NTCollection<TopTree::NTTau>;
     } else {
       p = new((void*) gvp) TopTree::NTCollection<TopTree::NTTau>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_240_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TopTree::NTCollection<TopTree::NTTau>*) G__getstructoffset())->Reset();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_240_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TopTree::NTCollection<TopTree::NTTau>*) G__getstructoffset())->Dump(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((TopTree::NTCollection<TopTree::NTTau>*) G__getstructoffset())->Dump();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_240_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TopTree::NTCollection<TopTree::NTTau>*) G__getstructoffset())->PrintListOfObjects(*(ostream*) libp->para[0].ref);
      G__setnull(result7);
      break;
   case 0:
      ((TopTree::NTCollection<TopTree::NTTau>*) G__getstructoffset())->PrintListOfObjects();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Dict_240_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TopTree::NTCollection<TopTree::NTTau>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TopTree::NTCollection<TopTree::NTTau>(*(TopTree::NTCollection<TopTree::NTTau>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TopTree::NTCollection<TopTree::NTTau> G__TTopTreecLcLNTCollectionlETopTreecLcLNTTaugR;
static int G__Dict_240_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TopTree::NTCollection<TopTree::NTTau>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TopTree::NTCollection<TopTree::NTTau>*) (soff+(sizeof(TopTree::NTCollection<TopTree::NTTau>)*i)))->~G__TTopTreecLcLNTCollectionlETopTreecLcLNTTaugR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TopTree::NTCollection<TopTree::NTTau>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TopTree::NTCollection<TopTree::NTTau>*) (soff))->~G__TTopTreecLcLNTCollectionlETopTreecLcLNTTaugR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Dict_240_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TopTree::NTCollection<TopTree::NTTau>* dest = (TopTree::NTCollection<TopTree::NTTau>*) G__getstructoffset();
   *dest = *(TopTree::NTCollection<TopTree::NTTau>*) libp->para[0].ref;
   const TopTree::NTCollection<TopTree::NTTau>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<string,bool> */
static int G__Dict_246_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<string,bool>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<string,bool>[n];
     } else {
       p = new((void*) gvp) pair<string,bool>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<string,bool>;
     } else {
       p = new((void*) gvp) pair<string,bool>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_pairlEstringcOboolgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Dict_246_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<string,bool>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<string,bool>(*(string*) libp->para[0].ref, *(bool*) G__Boolref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<string,bool>(*(string*) libp->para[0].ref, *(bool*) G__Boolref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_pairlEstringcOboolgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Dict_246_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<string,bool>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<string,bool>(*(pair<string,bool>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictLN_pairlEstringcOboolgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<string,bool> G__TpairlEstringcOboolgR;
static int G__Dict_246_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<string,bool>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<string,bool>*) (soff+(sizeof(pair<string,bool>)*i)))->~G__TpairlEstringcOboolgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<string,bool>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<string,bool>*) (soff))->~G__TpairlEstringcOboolgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */

/*********************************************************
* Member function Stub
*********************************************************/

/* TopTree::NTLepton */

/* TopTree::NTElectron */

/* TopTree::NTJet */

/* TopTree::NTPhoton */

/* TopTree::NTMuon */

/* TopTree::NTTau */

/* TopTree::NTMET */

/* TopTree::NTJetMet */

/* TopTree::NTCollection<TopTree::NTJet> */

/* TopTree::NTVertex */

/* TopTree::NTTrack */

/* TopTree::WDecaysMC */

/* TopTree::ZDecaysMC */

/* TopTree::TopDecaysMC */

/* TopTree::NTPU */

/* TopTree::NTEvent */

/* TopTree::NTCollection<TopTree::NTTau> */

/* pair<string,bool> */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncDict {
 public:
  G__Sizep2memfuncDict(): p(&G__Sizep2memfuncDict::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncDict::*p)();
};

size_t G__get_sizep2memfuncDict()
{
  G__Sizep2memfuncDict a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritanceDict() {

   /* Setting up class inheritance */
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTElectron))) {
     TopTree::NTElectron *G__Lderived;
     G__Lderived=(TopTree::NTElectron*)0x1000;
     {
       TopTree::NTLepton *G__Lpbase=(TopTree::NTLepton*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTElectron),G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTLepton),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMuon))) {
     TopTree::NTMuon *G__Lderived;
     G__Lderived=(TopTree::NTMuon*)0x1000;
     {
       TopTree::NTLepton *G__Lpbase=(TopTree::NTLepton*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMuon),G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTLepton),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTau))) {
     TopTree::NTTau *G__Lderived;
     G__Lderived=(TopTree::NTTau*)0x1000;
     {
       TopTree::NTLepton *G__Lpbase=(TopTree::NTLepton*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTau),G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTLepton),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTJetMet))) {
     TopTree::NTJetMet *G__Lderived;
     G__Lderived=(TopTree::NTJetMet*)0x1000;
     {
       TopTree::NTCollection<TopTree::NTJet> *G__Lpbase=(TopTree::NTCollection<TopTree::NTJet>*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTJetMet),G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetableDict() {

   /* Setting up typedef entry */
   G__search_typename2("vector<TSchemaHelper>",117,G__get_linked_tagnum(&G__DictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__DictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTBase<Float_t>",117,G__get_linked_tagnum(&G__DictLN_TMatrixTBaselEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTBase<Double_t>",117,G__get_linked_tagnum(&G__DictLN_TMatrixTBaselEdoublegR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TVectorT<Float_t>",117,G__get_linked_tagnum(&G__DictLN_TVectorTlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TVectorT<Double_t>",117,G__get_linked_tagnum(&G__DictLN_TVectorTlEdoublegR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixT<Float_t>",117,G__get_linked_tagnum(&G__DictLN_TMatrixTlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTRow_const<Float_t>",117,G__get_linked_tagnum(&G__DictLN_TMatrixTRow_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTColumn_const<Float_t>",117,G__get_linked_tagnum(&G__DictLN_TMatrixTColumn_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTDiag_const<Float_t>",117,G__get_linked_tagnum(&G__DictLN_TMatrixTDiag_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTFlat_const<Float_t>",117,G__get_linked_tagnum(&G__DictLN_TMatrixTFlat_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSub_const<Float_t>",117,G__get_linked_tagnum(&G__DictLN_TMatrixTSub_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSparseRow_const<Float_t>",117,G__get_linked_tagnum(&G__DictLN_TMatrixTSparseRow_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSparseDiag_const<Float_t>",117,G__get_linked_tagnum(&G__DictLN_TMatrixTSparseDiag_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTRow<Float_t>",117,G__get_linked_tagnum(&G__DictLN_TMatrixTRowlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTColumn<Float_t>",117,G__get_linked_tagnum(&G__DictLN_TMatrixTColumnlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTDiag<Float_t>",117,G__get_linked_tagnum(&G__DictLN_TMatrixTDiaglEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTFlat<Float_t>",117,G__get_linked_tagnum(&G__DictLN_TMatrixTFlatlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSub<Float_t>",117,G__get_linked_tagnum(&G__DictLN_TMatrixTSublEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSparseRow<Float_t>",117,G__get_linked_tagnum(&G__DictLN_TMatrixTSparseRowlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSparseDiag<Float_t>",117,G__get_linked_tagnum(&G__DictLN_TMatrixTSparseDiaglEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TElementActionT<Float_t>",117,G__get_linked_tagnum(&G__DictLN_TElementActionTlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TElementPosActionT<Float_t>",117,G__get_linked_tagnum(&G__DictLN_TElementPosActionTlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pair<std::string,float>",117,G__get_linked_tagnum(&G__DictLN_pairlEstringcOfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::pair<std::string,float> >",117,G__get_linked_tagnum(&G__DictLN_vectorlEpairlEstringcOfloatgRcOallocatorlEpairlEstringcOfloatgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlEpairlEstringcOfloatgRcOallocatorlEpairlEstringcOfloatgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlEpairlEstringcOfloatgRcOallocatorlEpairlEstringcOfloatgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlEpairlEstringcOfloatgRcOallocatorlEpairlEstringcOfloatgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlEpairlEstringcOfloatgRcOallocatorlEpairlEstringcOfloatgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<pair<string,float> >",117,G__get_linked_tagnum(&G__DictLN_vectorlEpairlEstringcOfloatgRcOallocatorlEpairlEstringcOfloatgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("NTCollection<NTJet>",117,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR),0,G__get_linked_tagnum(&G__DictLN_TopTree));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TopTree::NTJet>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTJetcOallocatorlETopTreecLcLNTJetgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTJetcOallocatorlETopTreecLcLNTJetgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTJetcOallocatorlETopTreecLcLNTJetgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTJetcOallocatorlETopTreecLcLNTJetgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTJetcOallocatorlETopTreecLcLNTJetgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TopTree::NTCollection<NTTau>",117,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR),0,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTEvent));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TopTree::NTTau>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTTaucOallocatorlETopTreecLcLNTTaugRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTTaucOallocatorlETopTreecLcLNTTaugRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTTaucOallocatorlETopTreecLcLNTTaugRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTTaucOallocatorlETopTreecLcLNTTaugRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTTaucOallocatorlETopTreecLcLNTTaugRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TopTree::NTCollection<NTTau>",117,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR),0,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTEvent));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pair<std::string,bool>",117,G__get_linked_tagnum(&G__DictLN_pairlEstringcOboolgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::pair<std::string,bool> >",117,G__get_linked_tagnum(&G__DictLN_vectorlEpairlEstringcOboolgRcOallocatorlEpairlEstringcOboolgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlEpairlEstringcOboolgRcOallocatorlEpairlEstringcOboolgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlEpairlEstringcOboolgRcOallocatorlEpairlEstringcOboolgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlEpairlEstringcOboolgRcOallocatorlEpairlEstringcOboolgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlEpairlEstringcOboolgRcOallocatorlEpairlEstringcOboolgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<pair<string,bool> >",117,G__get_linked_tagnum(&G__DictLN_vectorlEpairlEstringcOboolgRcOallocatorlEpairlEstringcOboolgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pair<std::string,int>",117,G__get_linked_tagnum(&G__DictLN_pairlEstringcOintgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::pair<std::string,int> >",117,G__get_linked_tagnum(&G__DictLN_vectorlEpairlEstringcOintgRcOallocatorlEpairlEstringcOintgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlEpairlEstringcOintgRcOallocatorlEpairlEstringcOintgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlEpairlEstringcOintgRcOallocatorlEpairlEstringcOintgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlEpairlEstringcOintgRcOallocatorlEpairlEstringcOintgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlEpairlEstringcOintgRcOallocatorlEpairlEstringcOintgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<pair<string,int> >",117,G__get_linked_tagnum(&G__DictLN_vectorlEpairlEstringcOintgRcOallocatorlEpairlEstringcOintgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TLorentzVector>",117,G__get_linked_tagnum(&G__DictLN_vectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<NTVertex>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTVertexcOallocatorlETopTreecLcLNTVertexgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTVertexcOallocatorlETopTreecLcLNTVertexgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTVertexcOallocatorlETopTreecLcLNTVertexgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTVertexcOallocatorlETopTreecLcLNTVertexgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTVertexcOallocatorlETopTreecLcLNTVertexgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TopTree::NTVertex>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTVertexcOallocatorlETopTreecLcLNTVertexgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<NTPU>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTPUcOallocatorlETopTreecLcLNTPUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTPUcOallocatorlETopTreecLcLNTPUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTPUcOallocatorlETopTreecLcLNTPUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTPUcOallocatorlETopTreecLcLNTPUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTPUcOallocatorlETopTreecLcLNTPUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TopTree::NTPU>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTPUcOallocatorlETopTreecLcLNTPUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<NTJetMet>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTJetMetcOallocatorlETopTreecLcLNTJetMetgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTJetMetcOallocatorlETopTreecLcLNTJetMetgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTJetMetcOallocatorlETopTreecLcLNTJetMetgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTJetMetcOallocatorlETopTreecLcLNTJetMetgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTJetMetcOallocatorlETopTreecLcLNTJetMetgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TopTree::NTJetMet>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTJetMetcOallocatorlETopTreecLcLNTJetMetgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<NTElectron>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTElectroncOallocatorlETopTreecLcLNTElectrongRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTElectroncOallocatorlETopTreecLcLNTElectrongRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTElectroncOallocatorlETopTreecLcLNTElectrongRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTElectroncOallocatorlETopTreecLcLNTElectrongRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTElectroncOallocatorlETopTreecLcLNTElectrongRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TopTree::NTElectron>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTElectroncOallocatorlETopTreecLcLNTElectrongRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<NTMuon>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTMuoncOallocatorlETopTreecLcLNTMuongRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTMuoncOallocatorlETopTreecLcLNTMuongRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTMuoncOallocatorlETopTreecLcLNTMuongRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTMuoncOallocatorlETopTreecLcLNTMuongRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTMuoncOallocatorlETopTreecLcLNTMuongRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TopTree::NTMuon>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTMuoncOallocatorlETopTreecLcLNTMuongRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TopTree::NTCollection<NTTau>",117,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR),0,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTEvent));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TopTree::NTCollection<NTTau> >",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRcOallocatorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRcOallocatorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRcOallocatorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRcOallocatorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRcOallocatorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TopTree::NTCollection<TopTree::NTTau> >",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRcOallocatorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<NTPhoton>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTPhotoncOallocatorlETopTreecLcLNTPhotongRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTPhotoncOallocatorlETopTreecLcLNTPhotongRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTPhotoncOallocatorlETopTreecLcLNTPhotongRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTPhotoncOallocatorlETopTreecLcLNTPhotongRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTPhotoncOallocatorlETopTreecLcLNTPhotongRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TopTree::NTPhoton>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTPhotoncOallocatorlETopTreecLcLNTPhotongRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<NTTrack>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTTrackcOallocatorlETopTreecLcLNTTrackgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTTrackcOallocatorlETopTreecLcLNTTrackgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTTrackcOallocatorlETopTreecLcLNTTrackgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTTrackcOallocatorlETopTreecLcLNTTrackgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTTrackcOallocatorlETopTreecLcLNTTrackgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TopTree::NTTrack>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTTrackcOallocatorlETopTreecLcLNTTrackgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<WDecaysMC>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLWDecaysMCcOallocatorlETopTreecLcLWDecaysMCgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLWDecaysMCcOallocatorlETopTreecLcLWDecaysMCgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLWDecaysMCcOallocatorlETopTreecLcLWDecaysMCgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLWDecaysMCcOallocatorlETopTreecLcLWDecaysMCgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLWDecaysMCcOallocatorlETopTreecLcLWDecaysMCgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TopTree::WDecaysMC>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLWDecaysMCcOallocatorlETopTreecLcLWDecaysMCgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ZDecaysMC>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLZDecaysMCcOallocatorlETopTreecLcLZDecaysMCgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLZDecaysMCcOallocatorlETopTreecLcLZDecaysMCgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLZDecaysMCcOallocatorlETopTreecLcLZDecaysMCgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLZDecaysMCcOallocatorlETopTreecLcLZDecaysMCgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLZDecaysMCcOallocatorlETopTreecLcLZDecaysMCgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TopTree::ZDecaysMC>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLZDecaysMCcOallocatorlETopTreecLcLZDecaysMCgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TopDecaysMC>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLTopDecaysMCcOallocatorlETopTreecLcLTopDecaysMCgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLTopDecaysMCcOallocatorlETopTreecLcLTopDecaysMCgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLTopDecaysMCcOallocatorlETopTreecLcLTopDecaysMCgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLTopDecaysMCcOallocatorlETopTreecLcLTopDecaysMCgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLTopDecaysMCcOallocatorlETopTreecLcLTopDecaysMCgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TopTree::TopDecaysMC>",117,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLTopDecaysMCcOallocatorlETopTreecLcLTopDecaysMCgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::vector<TLorentzVector> >",117,G__get_linked_tagnum(&G__DictLN_vectorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcOallocatorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcOallocatorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcOallocatorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictLN_reverse_iteratorlEvectorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcOallocatorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictLN_vectorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcOallocatorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<vector<TLorentzVector,allocator<TLorentzVector> > >",117,G__get_linked_tagnum(&G__DictLN_vectorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcOallocatorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* TopTree::NTLepton */
static void G__setup_memvarTopTreecLcLNTLepton(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTLepton));
   { TopTree::NTLepton *p; p=(TopTree::NTLepton*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->p4)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TLorentzVector),-1,-1,1,"p4=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->p4HLT)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TLorentzVector),-1,-1,1,"p4HLT=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->vertex)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TVector3),-1,-1,1,"vertex=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Charge)-(long)(p)),100,0,0,-1,-1,-1,1,"Charge=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TrkIso03)-(long)(p)),100,0,0,-1,-1,-1,1,"TrkIso03=",0,"summed track pt in a cone of deltaR<0.3");
   G__memvar_setup((void*)((long)(&p->ECaloIso03)-(long)(p)),100,0,0,-1,-1,-1,1,"ECaloIso03=",0,"ecal iso deposit from RecHits with electron footprint removed (cone = 0.3)");
   G__memvar_setup((void*)((long)(&p->HCaloIso03)-(long)(p)),100,0,0,-1,-1,-1,1,"HCaloIso03=",0,"hcal iso deposit from calo Towers (cone = 0.3)");
   G__memvar_setup((void*)((long)(&p->CaloIso03)-(long)(p)),100,0,0,-1,-1,-1,1,"CaloIso03=",0,"sum of ECaloIso and HCaloIso");
   G__memvar_setup((void*)((long)(&p->PATNeutralHadronIso)-(long)(p)),100,0,0,-1,-1,-1,1,"PATNeutralHadronIso=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PATChargedHadronIso)-(long)(p)),100,0,0,-1,-1,-1,1,"PATChargedHadronIso=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PATPhotonIso)-(long)(p)),100,0,0,-1,-1,-1,1,"PATPhotonIso=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PATTrackIso)-(long)(p)),100,0,0,-1,-1,-1,1,"PATTrackIso=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->D0)-(long)(p)),102,0,0,-1,-1,-1,1,"D0=",0,"Transverse IP");
   G__memvar_setup((void*)((long)(&p->Chi2)-(long)(p)),102,0,0,-1,-1,-1,1,"Chi2=",0,"Normalized chi2 ");
   G__memvar_setup((void*)((long)(&p->LeptonOrigin)-(long)(p)),105,0,0,-1,-1,-1,1,"LeptonOrigin=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->turnOnWeight)-(long)(p)),100,0,0,-1,-1,-1,1,"turnOnWeight=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TopTree::NTElectron */
static void G__setup_memvarTopTreecLcLNTElectron(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTElectron));
   { TopTree::NTElectron *p; p=(TopTree::NTElectron*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->isGsfElectron)-(long)(p)),103,0,0,-1,-1,-1,1,"isGsfElectron=",0,"* correspond to elec->ecalDrivenSeed () in PAT */");
   G__memvar_setup((void*)((long)(&p->ET_SC)-(long)(p)),102,0,0,-1,-1,-1,1,"ET_SC=",0,"* ET of the SuperCluster */");
   G__memvar_setup((void*)((long)(&p->nLost)-(long)(p)),105,0,0,-1,-1,-1,1,"nLost=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->elecIdLoose)-(long)(p)),105,0,0,-1,-1,-1,1,"elecIdLoose=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->elecIdTight)-(long)(p)),105,0,0,-1,-1,-1,1,"elecIdTight=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->elecIdRobustLoose)-(long)(p)),105,0,0,-1,-1,-1,1,"elecIdRobustLoose=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->elecIdRobustTight)-(long)(p)),105,0,0,-1,-1,-1,1,"elecIdRobustTight=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->elecIdWP90_c)-(long)(p)),105,0,0,-1,-1,-1,1,"elecIdWP90_c=",0,"* Working Point 90, combined iso (simple cut based ID) */ ");
   G__memvar_setup((void*)((long)(&p->elecIdWP90_r)-(long)(p)),105,0,0,-1,-1,-1,1,"elecIdWP90_r=",0,"* Working Point 90, relative iso (simple cut based ID) */");
   G__memvar_setup((void*)((long)(&p->cicVeryLoose)-(long)(p)),105,0,0,-1,-1,-1,1,"cicVeryLoose=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->cicLoose)-(long)(p)),105,0,0,-1,-1,-1,1,"cicLoose=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->cicMedium)-(long)(p)),105,0,0,-1,-1,-1,1,"cicMedium=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->cicTight)-(long)(p)),105,0,0,-1,-1,-1,1,"cicTight=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->cicSuperTight)-(long)(p)),105,0,0,-1,-1,-1,1,"cicSuperTight=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->cicHyperTight1)-(long)(p)),105,0,0,-1,-1,-1,1,"cicHyperTight1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->cicHyperTight2)-(long)(p)),105,0,0,-1,-1,-1,1,"cicHyperTight2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->cicHyperTight3)-(long)(p)),105,0,0,-1,-1,-1,1,"cicHyperTight3=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->cicVeryLooseMC)-(long)(p)),105,0,0,-1,-1,-1,1,"cicVeryLooseMC=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->cicLooseMC)-(long)(p)),105,0,0,-1,-1,-1,1,"cicLooseMC=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->cicMediumMC)-(long)(p)),105,0,0,-1,-1,-1,1,"cicMediumMC=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->cicTightMC)-(long)(p)),105,0,0,-1,-1,-1,1,"cicTightMC=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->cicSuperTightMC)-(long)(p)),105,0,0,-1,-1,-1,1,"cicSuperTightMC=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->cicHyperTight1MC)-(long)(p)),105,0,0,-1,-1,-1,1,"cicHyperTight1MC=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->cicHyperTight2MC)-(long)(p)),105,0,0,-1,-1,-1,1,"cicHyperTight2MC=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->cicHyperTight3MC)-(long)(p)),105,0,0,-1,-1,-1,1,"cicHyperTight3MC=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->isEB)-(long)(p)),105,0,0,-1,-1,-1,1,"isEB=",0,"isEE * 1 + isEB * 10");
   G__memvar_setup((void*)((long)(&p->isEcalDriven)-(long)(p)),103,0,0,-1,-1,-1,1,"isEcalDriven=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->elspike)-(long)(p)),102,0,0,-1,-1,-1,1,"elspike=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->eSuperClusterOverP)-(long)(p)),100,0,0,-1,-1,-1,1,"eSuperClusterOverP=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fbrem)-(long)(p)),100,0,0,-1,-1,-1,1,"fbrem=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->nlost)-(long)(p)),105,0,0,-1,-1,-1,1,"nlost=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->deltaCotTheta)-(long)(p)),102,0,0,-1,-1,-1,1,"deltaCotTheta=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->deltaDistance)-(long)(p)),102,0,0,-1,-1,-1,1,"deltaDistance=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TopTree::NTJet */
static void G__setup_memvarTopTreecLcLNTJet(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTJet));
   { TopTree::NTJet *p; p=(TopTree::NTJet*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->p4)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TLorentzVector),-1,-1,1,"p4=",0,"* 4 vector of jet.*/");
   G__memvar_setup((void*)((long)(&p->p4Gen)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TLorentzVector),-1,-1,1,"p4Gen=",0,"* 4 vector of gen jet.*/");
   G__memvar_setup((void*)((long)(&p->p4Parton)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TLorentzVector),-1,-1,1,"p4Parton=",0,"* 4 vector of gen jet.*/");
   G__memvar_setup((void*)((long)(&p->p4HLT)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TLorentzVector),-1,-1,1,"p4HLT=",0,"* 4 vector of matched HLT jet.*/");
   G__memvar_setup((void*)((long)(&p->emEnergyFraction)-(long)(p)),100,0,0,-1,-1,-1,1,"emEnergyFraction=",0,"* jet electromagnetic energy fraction  // ( not defined for pfjet)  */");
   G__memvar_setup((void*)((long)(&p->hadEnergyFraction)-(long)(p)),100,0,0,-1,-1,-1,1,"hadEnergyFraction=",0,"* jet hadronic energy fraction */");
   G__memvar_setup((void*)((long)(&p->CHEF)-(long)(p)),100,0,0,-1,-1,-1,1,"CHEF=",0,"* Charged Hadronic Energy Fraction */  ");
   G__memvar_setup((void*)((long)(&p->CEEF)-(long)(p)),100,0,0,-1,-1,-1,1,"CEEF=",0,"* Charged Electromagnetic Energy Fraction  (for Pf jet ID) */");
   G__memvar_setup((void*)((long)(&p->NHEF)-(long)(p)),100,0,0,-1,-1,-1,1,"NHEF=",0,"* Neutral Hadronic Energy Fraction  */");
   G__memvar_setup((void*)((long)(&p->NEEF)-(long)(p)),100,0,0,-1,-1,-1,1,"NEEF=",0,"* Neutral Electromagnetic Energy Fraction */  ");
   G__memvar_setup((void*)((long)(&p->n90Hits)-(long)(p)),100,0,0,-1,-1,-1,1,"n90Hits=",0,"* Number of recHits (i.e. cells) needed to make up 90% of the jet's energy ");
   G__memvar_setup((void*)((long)(&p->fHPD)-(long)(p)),100,0,0,-1,-1,-1,1,"fHPD=",0,"* fraction of jet energy from the highest energy Hybrid Photo Diode (not for pfjet) */");
   G__memvar_setup((void*)((long)(&p->passJetID)-(long)(p)),103,0,0,-1,-1,-1,1,"passJetID=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->partonFlavour)-(long)(p)),105,0,0,-1,-1,-1,1,"partonFlavour=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->DiscriPair)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlEpairlEstringcOfloatgRcOallocatorlEpairlEstringcOfloatgRsPgRsPgR),G__defined_typename("vector<std::pair<std::string,float> >"),-1,1,"DiscriPair=",0,"* dump of PAT content for all the taggers */");
   G__memvar_setup((void*)((long)(&p->TCDiscri)-(long)(p)),100,0,0,-1,-1,-1,1,"TCDiscri=",0,"* b-tagging discriminator for TrackCounting algorithm */");
   G__memvar_setup((void*)((long)(&p->SVDiscri)-(long)(p)),100,0,0,-1,-1,-1,1,"SVDiscri=",0,"* b-tagging discriminator for SecondaryVertex algorithm */");
   G__memvar_setup((void*)((long)(&p->SMDiscri)-(long)(p)),100,0,0,-1,-1,-1,1,"SMDiscri=",0,"* b-tagging discriminator for SM algorithm */");
   G__memvar_setup((void*)((long)(&p->nTracks)-(long)(p)),105,0,0,-1,-1,-1,1,"nTracks=",0,"* number of tracks associated to the jet */");
   G__memvar_setup((void*)((long)(&p->sumPtTracks)-(long)(p)),105,0,0,-1,-1,-1,1,"sumPtTracks=",0,"* the scalar sum of Pt of the nTracks tracks */ ");
   G__memvar_setup((void*)((long)(&p->nTracksSVX)-(long)(p)),105,0,0,-1,-1,-1,1,"nTracksSVX=",0,"* number of tracks from SV tagger (== IP tagger) */");
   G__memvar_setup((void*)((long)(&p->nSVX)-(long)(p)),105,0,0,-1,-1,-1,1,"nSVX=",0,"* number of Secondary Vertices */");
   G__memvar_setup((void*)((long)(&p->chi2SVX)-(long)(p)),100,0,0,-1,-1,-1,1,"chi2SVX=",0,"* chi2 of the best secondary vertex */");
   G__memvar_setup((void*)((long)(&p->ndofSVX)-(long)(p)),100,0,0,-1,-1,-1,1,"ndofSVX=",0,"* ndof of the best secondary vertex */");
   G__memvar_setup((void*)((long)(&p->flightDistanceSVX)-(long)(p)),100,0,0,-1,-1,-1,1,"flightDistanceSVX=",0,"* distance (3D)  between primary and best secondary vertex */");
   G__memvar_setup((void*)((long)(&p->flightDistanceSigSVX)-(long)(p)),100,0,0,-1,-1,-1,1,"flightDistanceSigSVX=",0,"* distance significance (3D) between primary and secondary vertex */");
   G__memvar_setup((void*)((long)(&p->flightDistanceErrSVX)-(long)(p)),100,0,0,-1,-1,-1,1,"flightDistanceErrSVX=",0,"* distance error (3D) between primary and secondary vertex */");
   G__memvar_setup((void*)((long)(&p->MassSVX)-(long)(p)),100,0,0,-1,-1,-1,1,"MassSVX=",0,"* inv. mass of the best secondary vertex */");
   G__memvar_setup((void*)((long)(&p->turnOnWeight)-(long)(p)),100,0,0,-1,-1,-1,1,"turnOnWeight=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->corrJES)-(long)(p)),100,0,0,-1,-1,-1,1,"corrJES=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TopTree::NTPhoton */
static void G__setup_memvarTopTreecLcLNTPhoton(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTPhoton));
   { TopTree::NTPhoton *p; p=(TopTree::NTPhoton*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->p4)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TLorentzVector),-1,-1,1,"p4=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TrkIso)-(long)(p)),100,0,0,-1,-1,-1,1,"TrkIso=",0,"summed track pt in a cone of deltaR<0.4");
   G__memvar_setup((void*)((long)(&p->ECaloIso)-(long)(p)),100,0,0,-1,-1,-1,1,"ECaloIso=",0,"ecal iso deposit from RecHits with electron footprint removed (cone = 0.4)");
   G__memvar_setup((void*)((long)(&p->HCaloIso)-(long)(p)),100,0,0,-1,-1,-1,1,"HCaloIso=",0,"hcal iso deposit from calo Towers (cone = 0.4)");
   G__memvar_setup((void*)((long)(&p->isEB)-(long)(p)),103,0,0,-1,-1,-1,1,"isEB=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->e1x5)-(long)(p)),102,0,0,-1,-1,-1,1,"e1x5=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->e2x5)-(long)(p)),102,0,0,-1,-1,-1,1,"e2x5=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->e3x3)-(long)(p)),102,0,0,-1,-1,-1,1,"e3x3=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->e5x5)-(long)(p)),102,0,0,-1,-1,-1,1,"e5x5=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TopTree::NTMuon */
static void G__setup_memvarTopTreecLcLNTMuon(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMuon));
   { TopTree::NTMuon *p; p=(TopTree::NTMuon*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->MuonType)-(long)(p)),105,0,0,-1,-1,-1,1,"MuonType=",0,"* IsGlobalMuon * 100 + IsStandAloneMuon * 10 + IsTrackerMuon * 1; */");
   G__memvar_setup((void*)((long)(&p->GlobalMuonPromptTight)-(long)(p)),105,0,0,-1,-1,-1,1,"GlobalMuonPromptTight=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->NTrValidHits)-(long)(p)),105,0,0,-1,-1,-1,1,"NTrValidHits=",0,"* nof valid hits associated to the tracker track */");
   G__memvar_setup((void*)((long)(&p->NValidHits)-(long)(p)),105,0,0,-1,-1,-1,1,"NValidHits=",0,"* nof valid hits associated to the global track */");
   G__memvar_setup((void*)((long)(&p->D0Inner)-(long)(p)),102,0,0,-1,-1,-1,1,"D0Inner=",0,"Transverse IP from tracks");
   G__memvar_setup((void*)((long)(&p->NOfMatches)-(long)(p)),105,0,0,-1,-1,-1,1,"NOfMatches=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TopTree::NTTau */
static void G__setup_memvarTopTreecLcLNTTau(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTau));
   { TopTree::NTTau *p; p=(TopTree::NTTau*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->leadTrackPt)-(long)(p)),100,0,0,-1,-1,-1,1,"leadTrackPt=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->numSigConeTracks)-(long)(p)),100,0,0,-1,-1,-1,1,"numSigConeTracks=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->numIsoConeTracks)-(long)(p)),100,0,0,-1,-1,-1,1,"numIsoConeTracks=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->decay)-(long)(p)),105,0,0,-1,-1,-1,1,"decay=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->isolationPFChargedHadrCandsPtSum)-(long)(p)),102,0,0,-1,-1,-1,1,"isolationPFChargedHadrCandsPtSum=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->isolationPFGammaCandsEtSum)-(long)(p)),102,0,0,-1,-1,-1,1,"isolationPFGammaCandsEtSum=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->maximumHCALPFClusterEt)-(long)(p)),102,0,0,-1,-1,-1,1,"maximumHCALPFClusterEt=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->emFraction)-(long)(p)),102,0,0,-1,-1,-1,1,"emFraction=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->hcalTotOverPLead)-(long)(p)),102,0,0,-1,-1,-1,1,"hcalTotOverPLead=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->hcalMaxOverPLead)-(long)(p)),102,0,0,-1,-1,-1,1,"hcalMaxOverPLead=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->hcal3x3OverPLead)-(long)(p)),102,0,0,-1,-1,-1,1,"hcal3x3OverPLead=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ecalStripSumEOverPLead)-(long)(p)),102,0,0,-1,-1,-1,1,"ecalStripSumEOverPLead=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->decayMode)-(long)(p)),105,0,0,-1,-1,-1,1,"decayMode=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->tauIDs)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlEpairlEstringcOfloatgRcOallocatorlEpairlEstringcOfloatgRsPgRsPgR),G__defined_typename("vector<std::pair<std::string,float> >"),-1,1,"tauIDs=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TopTree::NTMET */
static void G__setup_memvarTopTreecLcLNTMET(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMET));
   { TopTree::NTMET *p; p=(TopTree::NTMET*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->p4)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TLorentzVector),-1,-1,1,"p4=",0,"* missing Et vector -->> 4D vector since no 2D object available in [root/5.14.00f-CMS3q] ... */");
   G__memvar_setup((void*)((long)(&p->correction)-(long)(p)),100,0,0,-1,-1,-1,1,"correction=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->turnOnWeight)-(long)(p)),100,0,0,-1,-1,-1,1,"turnOnWeight=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TopTree::NTJetMet */
static void G__setup_memvarTopTreecLcLNTJetMet(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTJetMet));
   { TopTree::NTJetMet *p; p=(TopTree::NTJetMet*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->met)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMET),-1,-1,1,"met=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->sumEtJet)-(long)(p)),100,0,0,-1,-1,-1,1,"sumEtJet=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->sumEtJetRaw)-(long)(p)),100,0,0,-1,-1,-1,1,"sumEtJetRaw=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TopTree::NTCollection<TopTree::NTJet> */
static void G__setup_memvarTopTreecLcLNTCollectionlETopTreecLcLNTJetgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR));
   { TopTree::NTCollection<TopTree::NTJet> *p; p=(TopTree::NTCollection<TopTree::NTJet>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->objects)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTJetcOallocatorlETopTreecLcLNTJetgRsPgR),G__defined_typename("vector<TopTree::NTJet>"),-1,1,"objects=",0,"object = TopTree::NTJet or TopTree::NTTau...");
   G__memvar_setup((void*)((long)(&p->algo)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_string),-1,-1,1,"algo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TopTree::NTVertex */
static void G__setup_memvarTopTreecLcLNTVertex(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTVertex));
   { TopTree::NTVertex *p; p=(TopTree::NTVertex*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->p3)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TVector3),-1,-1,1,"p3=",0,"*X-Y-Z coordinates */");
   G__memvar_setup((void*)((long)(&p->chi2)-(long)(p)),100,0,0,-1,-1,-1,1,"chi2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->isFake)-(long)(p)),105,0,0,-1,-1,-1,1,"isFake=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->isValid)-(long)(p)),105,0,0,-1,-1,-1,1,"isValid=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ndof)-(long)(p)),100,0,0,-1,-1,-1,1,"ndof=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->rho)-(long)(p)),100,0,0,-1,-1,-1,1,"rho=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->normalizedChi2)-(long)(p)),100,0,0,-1,-1,-1,1,"normalizedChi2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->NumberOfTracks)-(long)(p)),105,0,0,-1,-1,-1,1,"NumberOfTracks=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TopTree::NTTrack */
static void G__setup_memvarTopTreecLcLNTTrack(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTrack));
   { TopTree::NTTrack *p; p=(TopTree::NTTrack*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->p4)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TLorentzVector),-1,-1,1,"p4=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->charge)-(long)(p)),105,0,0,-1,-1,-1,1,"charge=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Chi2)-(long)(p)),100,0,0,-1,-1,-1,1,"Chi2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->d0)-(long)(p)),100,0,0,-1,-1,-1,1,"d0=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->d0Error)-(long)(p)),100,0,0,-1,-1,-1,1,"d0Error=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->dxy)-(long)(p)),100,0,0,-1,-1,-1,1,"dxy=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->dxy_BS)-(long)(p)),100,0,0,-1,-1,-1,1,"dxy_BS=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->dxyError)-(long)(p)),100,0,0,-1,-1,-1,1,"dxyError=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->dz)-(long)(p)),100,0,0,-1,-1,-1,1,"dz=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->dzError)-(long)(p)),100,0,0,-1,-1,-1,1,"dzError=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TopTree::WDecaysMC */
static void G__setup_memvarTopTreecLcLWDecaysMC(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLWDecaysMC));
   { TopTree::WDecaysMC *p; p=(TopTree::WDecaysMC*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->Q_Lep_gen)-(long)(p)),100,0,0,-1,-1,-1,1,"Q_Lep_gen=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->p4_W_gen)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TLorentzVector),-1,-1,1,"p4_W_gen=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->p4_Lep_gen)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TLorentzVector),-1,-1,1,"p4_Lep_gen=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->p4_Neu_gen)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TLorentzVector),-1,-1,1,"p4_Neu_gen=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->p4_SumTauNeu_gen)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TLorentzVector),-1,-1,1,"p4_SumTauNeu_gen=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Tmeme)-(long)(p)),105,0,0,-1,-1,-1,1,"Tmeme=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->mcLepId)-(long)(p)),105,0,0,-1,-1,-1,1,"mcLepId=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TopTree::ZDecaysMC */
static void G__setup_memvarTopTreecLcLZDecaysMC(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLZDecaysMC));
   { TopTree::ZDecaysMC *p; p=(TopTree::ZDecaysMC*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->p4_Z_gen)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TLorentzVector),-1,-1,1,"p4_Z_gen=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->p4_Lep1_gen)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TLorentzVector),-1,-1,1,"p4_Lep1_gen=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->p4_Lep2_gen)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TLorentzVector),-1,-1,1,"p4_Lep2_gen=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->p4_SumTauNeu_gen)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TLorentzVector),-1,-1,1,"p4_SumTauNeu_gen=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->p4_SumTauANeu_gen)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TLorentzVector),-1,-1,1,"p4_SumTauANeu_gen=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Q_Lep1_gen)-(long)(p)),100,0,0,-1,-1,-1,1,"Q_Lep1_gen=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Q_Lep2_gen)-(long)(p)),100,0,0,-1,-1,-1,1,"Q_Lep2_gen=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Lep1_pdgID)-(long)(p)),105,0,0,-1,-1,-1,1,"Lep1_pdgID=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Lep2_pdgID)-(long)(p)),105,0,0,-1,-1,-1,1,"Lep2_pdgID=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Tmeme)-(long)(p)),105,0,0,-1,-1,-1,1,"Tmeme=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Zgtobb)-(long)(p)),105,0,0,-1,-1,-1,1,"Zgtobb=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TopTree::TopDecaysMC */
static void G__setup_memvarTopTreecLcLTopDecaysMC(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLTopDecaysMC));
   { TopTree::TopDecaysMC *p; p=(TopTree::TopDecaysMC*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->Q_gen)-(long)(p)),100,0,0,-1,-1,-1,1,"Q_gen=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->p4_b_gen)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TLorentzVector),-1,-1,1,"p4_b_gen=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->p4_t_gen)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TLorentzVector),-1,-1,1,"p4_t_gen=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->mcLepId)-(long)(p)),105,0,0,-1,-1,-1,1,"mcLepId=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TopTree::NTPU */
static void G__setup_memvarTopTreecLcLNTPU(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTPU));
   { TopTree::NTPU *p; p=(TopTree::NTPU*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->bunchCrossing)-(long)(p)),105,0,0,-1,-1,-1,1,"bunchCrossing=",0,"to which bunch crossing does this interaction belong?  ");
   G__memvar_setup((void*)((long)(&p->zpositions)-(long)(p)),102,0,0,-1,-1,-1,1,"zpositions=",0,"the true primary vertex position along the z axis for each added interaction");
   G__memvar_setup((void*)((long)(&p->sumpT_lowpT)-(long)(p)),102,0,0,-1,-1,-1,1,"sumpT_lowpT=",0,"the sum of the transverse momentum of the tracks originating from each interaction, where track pT > low_cut");
   G__memvar_setup((void*)((long)(&p->sumpT_highpT)-(long)(p)),102,0,0,-1,-1,-1,1,"sumpT_highpT=",0,"the sum of the transverse momentum of the tracks originating from each interaction, where track pT > high_cut");
   G__memvar_setup((void*)((long)(&p->ntrks_lowpT)-(long)(p)),105,0,0,-1,-1,-1,1,"ntrks_lowpT=",0,"the number of tracks originating from each interaction, where track pT > low_cut");
   G__memvar_setup((void*)((long)(&p->ntrks_highpT)-(long)(p)),105,0,0,-1,-1,-1,1,"ntrks_highpT=",0,"the number of tracks originating from each interaction, where track pT > high_cut");
   }
   G__tag_memvar_reset();
}


   /* TopTree::NTEvent */
static void G__setup_memvarTopTreecLcLNTEvent(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTEvent));
   { TopTree::NTEvent *p; p=(TopTree::NTEvent*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->runNb)-(long)(p)),104,0,0,-1,-1,-1,1,"runNb=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->eventNb)-(long)(p)),104,0,0,-1,-1,-1,1,"eventNb=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->eventWeight)-(long)(p)),100,0,0,-1,-1,-1,1,"eventWeight=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->lumiblock)-(long)(p)),105,0,0,-1,-1,-1,1,"lumiblock=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->procId)-(long)(p)),105,0,0,-1,-1,-1,1,"procId=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->eventType)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_string),-1,-1,1,"eventType=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TMEME)-(long)(p)),105,0,0,-1,-1,-1,1,"TMEME=",0,"*");
   G__memvar_setup((void*)((long)(&p->ptHat)-(long)(p)),105,0,0,-1,-1,-1,1,"ptHat=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->pdgIdPartons)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_pairlEintcOintgR),-1,-1,1,"pdgIdPartons=",0,"* pdgId of the initial partons */");
   G__memvar_setup((void*)((long)(&p->triggers)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlEpairlEstringcOboolgRcOallocatorlEpairlEstringcOboolgRsPgRsPgR),G__defined_typename("vector<std::pair<std::string,bool> >"),-1,1,"triggers=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->match_HLT_Ele10_LW_L1R_recoEl)-(long)(p)),102,0,0,-1,-1,-1,1,"match_HLT_Ele10_LW_L1R_recoEl=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->prescales)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlEpairlEstringcOintgRcOallocatorlEpairlEstringcOintgRsPgRsPgR),G__defined_typename("vector<std::pair<std::string,int> >"),-1,1,"prescales=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->tauObjTrig)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgR),G__defined_typename("vector<TLorentzVector>"),-1,1,"tauObjTrig=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->jetObjTrig)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgR),G__defined_typename("vector<TLorentzVector>"),-1,1,"jetObjTrig=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->VertexVec)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTVertexcOallocatorlETopTreecLcLNTVertexgRsPgR),G__defined_typename("vector<NTVertex>"),-1,1,"VertexVec=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->p3BS)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TVector3),-1,-1,1,"p3BS=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->p3BSErr)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_TVector3),-1,-1,1,"p3BSErr=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->rho_PUUE_dens)-(long)(p)),100,0,0,-1,-1,-1,1,"rho_PUUE_dens=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->neutralRho_PUUE_dens)-(long)(p)),100,0,0,-1,-1,-1,1,"neutralRho_PUUE_dens=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->num_pileup_bc0)-(long)(p)),105,0,0,-1,-1,-1,1,"num_pileup_bc0=",0,"the number of pileup interactions of Bunch Crossing  0, that have been added to the event");
   G__memvar_setup((void*)((long)(&p->num_pileup_bcp1)-(long)(p)),105,0,0,-1,-1,-1,1,"num_pileup_bcp1=",0,"the number of pileup interactions of Bunch Crossing p1, that have been added to the event");
   G__memvar_setup((void*)((long)(&p->num_pileup_bcm1)-(long)(p)),105,0,0,-1,-1,-1,1,"num_pileup_bcm1=",0,"the number of pileup interactions of Bunch Crossing m1, that have been added to the event");
   G__memvar_setup((void*)((long)(&p->pileup)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTPUcOallocatorlETopTreecLcLNTPUgRsPgR),G__defined_typename("vector<NTPU>"),-1,1,"pileup=",0,"dedicated PU information");
   G__memvar_setup((void*)((long)(&p->jetMetVec)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTJetMetcOallocatorlETopTreecLcLNTJetMetgRsPgR),G__defined_typename("vector<NTJetMet>"),-1,1,"jetMetVec=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->electrons)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTElectroncOallocatorlETopTreecLcLNTElectrongRsPgR),G__defined_typename("vector<NTElectron>"),-1,1,"electrons=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->muons)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTMuoncOallocatorlETopTreecLcLNTMuongRsPgR),G__defined_typename("vector<NTMuon>"),-1,1,"muons=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->tausVec)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRcOallocatorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgRsPgR),G__defined_typename("vector<TopTree::NTCollection<NTTau> >"),-1,1,"tausVec=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->photons)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTPhotoncOallocatorlETopTreecLcLNTPhotongRsPgR),G__defined_typename("vector<NTPhoton>"),-1,1,"photons=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->tracks)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTTrackcOallocatorlETopTreecLcLNTTrackgRsPgR),G__defined_typename("vector<NTTrack>"),-1,1,"tracks=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Generatedtaus)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgR),G__defined_typename("vector<TLorentzVector>"),-1,1,"Generatedtaus=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->GeneratedAtaus)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgR),G__defined_typename("vector<TLorentzVector>"),-1,1,"GeneratedAtaus=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->genBquarks)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgR),G__defined_typename("vector<TLorentzVector>"),-1,1,"genBquarks=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->genCquarks)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgR),G__defined_typename("vector<TLorentzVector>"),-1,1,"genCquarks=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->genLquarks)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgR),G__defined_typename("vector<TLorentzVector>"),-1,1,"genLquarks=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->genGquarks)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgR),G__defined_typename("vector<TLorentzVector>"),-1,1,"genGquarks=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->wAndDecays)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLWDecaysMCcOallocatorlETopTreecLcLWDecaysMCgRsPgR),G__defined_typename("vector<WDecaysMC>"),-1,1,"wAndDecays=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->zAndDecays)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLZDecaysMCcOallocatorlETopTreecLcLZDecaysMCgRsPgR),G__defined_typename("vector<ZDecaysMC>"),-1,1,"zAndDecays=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->topAndDecays)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLTopDecaysMCcOallocatorlETopTreecLcLTopDecaysMCgRsPgR),G__defined_typename("vector<TopDecaysMC>"),-1,1,"topAndDecays=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->GeneratedtausLepPlusDecays)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcOallocatorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRsPgRsPgR),G__defined_typename("vector<std::vector<TLorentzVector> >"),-1,1,"GeneratedtausLepPlusDecays=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->GeneratedtausLepMinusDecays)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcOallocatorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRsPgRsPgR),G__defined_typename("vector<std::vector<TLorentzVector> >"),-1,1,"GeneratedtausLepMinusDecays=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->GeneratedtausPionPlusDecays)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcOallocatorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRsPgRsPgR),G__defined_typename("vector<std::vector<TLorentzVector> >"),-1,1,"GeneratedtausPionPlusDecays=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->GeneratedtausPionMinusDecays)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcOallocatorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRsPgRsPgR),G__defined_typename("vector<std::vector<TLorentzVector> >"),-1,1,"GeneratedtausPionMinusDecays=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->wPlusAndDecays)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLWDecaysMCcOallocatorlETopTreecLcLWDecaysMCgRsPgR),G__defined_typename("vector<WDecaysMC>"),-1,1,"wPlusAndDecays=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->wMinusAndDecays)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLWDecaysMCcOallocatorlETopTreecLcLWDecaysMCgRsPgR),G__defined_typename("vector<WDecaysMC>"),-1,1,"wMinusAndDecays=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->topPlusAndDecays)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLTopDecaysMCcOallocatorlETopTreecLcLTopDecaysMCgRsPgR),G__defined_typename("vector<TopDecaysMC>"),-1,1,"topPlusAndDecays=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->topMinusAndDecays)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLTopDecaysMCcOallocatorlETopTreecLcLTopDecaysMCgRsPgR),G__defined_typename("vector<TopDecaysMC>"),-1,1,"topMinusAndDecays=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->pdfWeights)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlEfloatcOallocatorlEfloatgRsPgR),G__defined_typename("vector<float>"),-1,1,"pdfWeights=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->partonFlavor1)-(long)(p)),105,0,0,-1,-1,-1,1,"partonFlavor1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->partonFlavor2)-(long)(p)),105,0,0,-1,-1,-1,1,"partonFlavor2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->x1)-(long)(p)),102,0,0,-1,-1,-1,1,"x1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->x2)-(long)(p)),102,0,0,-1,-1,-1,1,"x2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Q_scale)-(long)(p)),102,0,0,-1,-1,-1,1,"Q_scale=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TopTree::NTCollection<TopTree::NTTau> */
static void G__setup_memvarTopTreecLcLNTCollectionlETopTreecLcLNTTaugR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR));
   { TopTree::NTCollection<TopTree::NTTau> *p; p=(TopTree::NTCollection<TopTree::NTTau>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->objects)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_vectorlETopTreecLcLNTTaucOallocatorlETopTreecLcLNTTaugRsPgR),G__defined_typename("vector<TopTree::NTTau>"),-1,1,"objects=",0,"object = TopTree::NTJet or TopTree::NTTau...");
   G__memvar_setup((void*)((long)(&p->algo)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_string),-1,-1,1,"algo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<string,bool> */
static void G__setup_memvarpairlEstringcOboolgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictLN_pairlEstringcOboolgR));
   { pair<string,bool> *p; p=(pair<string,bool>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictLN_string),-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),103,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarDict() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncTopTreecLcLNTLepton(void) {
   /* TopTree::NTLepton */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTLepton));
   G__memfunc_setup("NTLepton",788,G__Dict_215_0_1, 105, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTLepton), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Reset",515,G__Dict_215_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RelIso03",689,G__Dict_215_0_3, 100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RelIso03PF",839,G__Dict_215_0_4, 100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RelIso03RhoCorrected",1909,G__Dict_215_0_5, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - rho", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RelIso03PFRhoCorrected",2059,G__Dict_215_0_6, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - rho", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RelIso03NeutralRhoCorrected",2640,G__Dict_215_0_7, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - rho", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RelIso03PFNeutralRhoCorrected",2790,G__Dict_215_0_8, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - rho", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PrintInfo",921,G__Dict_215_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PrintP4",657,G__Dict_215_0_10, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TLorentzVector' - 0 - a u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PrintP3",656,G__Dict_215_0_11, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TVector3' - 0 - a u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("NTLepton", 788, G__Dict_215_0_12, (int) ('i'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTLepton), -1, 0, 1, 1, 1, 0, "u 'TopTree::NTLepton' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~NTLepton", 914, G__Dict_215_0_13, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Dict_215_0_14, (int) ('u'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTLepton), -1, 1, 1, 1, 1, 0, "u 'TopTree::NTLepton' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTopTreecLcLNTElectron(void) {
   /* TopTree::NTElectron */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTElectron));
   G__memfunc_setup("NTElectron",990,G__Dict_216_0_1, 105, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTElectron), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Reset",515,G__Dict_216_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("isNotConv",931,G__Dict_216_0_3, 103, -1, -1, 0, 1, 1, 1, 8, "i - - 0 - elecId", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("hadId",474,G__Dict_216_0_4, 103, -1, -1, 0, 1, 1, 1, 8, "i - - 0 - elecId", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Dump",406,G__Dict_216_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNTElectron",1278,G__Dict_216_0_6, 117, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTElectron), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNTElectronPointer",2015,G__Dict_216_0_7, 85, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTElectron), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CombinedRelIso03",1490,G__Dict_216_0_8, 102, -1, -1, 0, 0, 1, 1, 0, "", "* consider Barrel & EndCap cases */", (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("NTElectron", 990, G__Dict_216_0_9, (int) ('i'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTElectron), -1, 0, 1, 1, 1, 0, "u 'TopTree::NTElectron' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~NTElectron", 1116, G__Dict_216_0_10, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Dict_216_0_11, (int) ('u'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTElectron), -1, 1, 1, 1, 1, 0, "u 'TopTree::NTElectron' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTopTreecLcLNTJet(void) {
   /* TopTree::NTJet */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTJet));
   G__memfunc_setup("NTJet",453,G__Dict_217_0_1, 105, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTJet), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Reset",515,G__Dict_217_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Dump",406,G__Dict_217_0_3, 121, -1, -1, 0, 1, 1, 1, 0, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PrintP4",657,G__Dict_217_0_4, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TLorentzVector' - 0 - a u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNTJet",741,G__Dict_217_0_5, 117, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTJet), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNTJetPointer",1478,G__Dict_217_0_6, 85, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTJet), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetDiscri",894,G__Dict_217_0_7, 102, -1, -1, 0, 1, 1, 1, 8, "u 'string' - 0 - algo", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("NTJet", 453, G__Dict_217_0_8, (int) ('i'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTJet), -1, 0, 1, 1, 1, 0, "u 'TopTree::NTJet' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~NTJet", 579, G__Dict_217_0_9, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Dict_217_0_10, (int) ('u'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTJet), -1, 1, 1, 1, 1, 0, "u 'TopTree::NTJet' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTopTreecLcLNTPhoton(void) {
   /* TopTree::NTPhoton */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTPhoton));
   G__memfunc_setup("NTPhoton",794,G__Dict_223_0_1, 105, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTPhoton), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Reset",515,G__Dict_223_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PrintInfo",921,G__Dict_223_0_3, 121, -1, -1, 0, 1, 1, 1, 0, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PrintP4",657,G__Dict_223_0_4, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TLorentzVector' - 0 - a u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PrintP3",656,G__Dict_223_0_5, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TVector3' - 0 - a u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("NTPhoton", 794, G__Dict_223_0_6, (int) ('i'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTPhoton), -1, 0, 1, 1, 1, 0, "u 'TopTree::NTPhoton' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~NTPhoton", 920, G__Dict_223_0_7, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Dict_223_0_8, (int) ('u'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTPhoton), -1, 1, 1, 1, 1, 0, "u 'TopTree::NTPhoton' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTopTreecLcLNTMuon(void) {
   /* TopTree::NTMuon */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMuon));
   G__memfunc_setup("NTMuon",577,G__Dict_224_0_1, 105, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMuon), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Reset",515,G__Dict_224_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Dump",406,G__Dict_224_0_3, 121, -1, -1, 0, 1, 1, 1, 0, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNTMuon",865,G__Dict_224_0_4, 117, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMuon), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNTMuonPointer",1602,G__Dict_224_0_5, 85, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMuon), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("NTMuon", 577, G__Dict_224_0_6, (int) ('i'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMuon), -1, 0, 1, 1, 1, 0, "u 'TopTree::NTMuon' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~NTMuon", 703, G__Dict_224_0_7, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Dict_224_0_8, (int) ('u'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMuon), -1, 1, 1, 1, 1, 0, "u 'TopTree::NTMuon' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTopTreecLcLNTTau(void) {
   /* TopTree::NTTau */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTau));
   G__memfunc_setup("NTTau",460,G__Dict_225_0_1, 105, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTau), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Reset",515,G__Dict_225_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Dump",406,G__Dict_225_0_3, 121, -1, -1, 0, 1, 1, 1, 0, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNTTau",748,G__Dict_225_0_4, 117, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTau), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNTTauPointer",1485,G__Dict_225_0_5, 85, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTau), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetDiscriminator",1656,G__Dict_225_0_6, 105, -1, -1, 0, 1, 1, 1, 0, "u 'string' - 0 - discriminatorName", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("NTTau", 460, G__Dict_225_0_7, (int) ('i'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTau), -1, 0, 1, 1, 1, 0, "u 'TopTree::NTTau' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~NTTau", 586, G__Dict_225_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Dict_225_0_9, (int) ('u'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTau), -1, 1, 1, 1, 1, 0, "u 'TopTree::NTTau' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTopTreecLcLNTMET(void) {
   /* TopTree::NTMET */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMET));
   G__memfunc_setup("NTMET",392,G__Dict_226_0_1, 105, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMET), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Reset",515,G__Dict_226_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Dump",406,G__Dict_226_0_3, 121, -1, -1, 0, 1, 1, 1, 0, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PrintP4",657,G__Dict_226_0_4, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TLorentzVector' - 0 - a u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNTMET",680,G__Dict_226_0_5, 117, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMET), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNTMETPointer",1417,G__Dict_226_0_6, 85, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMET), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("NTMET", 392, G__Dict_226_0_7, (int) ('i'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMET), -1, 0, 1, 1, 1, 0, "u 'TopTree::NTMET' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~NTMET", 518, G__Dict_226_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Dict_226_0_9, (int) ('u'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMET), -1, 1, 1, 1, 1, 0, "u 'TopTree::NTMET' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTopTreecLcLNTJetMet(void) {
   /* TopTree::NTJetMet */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTJetMet));
   G__memfunc_setup("NTJetMet",747,G__Dict_227_0_1, 105, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTJetMet), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Reset",515,G__Dict_227_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("NTJetMet", 747, G__Dict_227_0_3, (int) ('i'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTJetMet), -1, 0, 1, 1, 1, 0, "u 'TopTree::NTJetMet' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~NTJetMet", 873, G__Dict_227_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Dict_227_0_5, (int) ('u'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTJetMet), -1, 1, 1, 1, 1, 0, "u 'TopTree::NTJetMet' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTopTreecLcLNTCollectionlETopTreecLcLNTJetgR(void) {
   /* TopTree::NTCollection<TopTree::NTJet> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR));
   G__memfunc_setup("NTCollection<TopTree::NTJet>",2596,G__Dict_228_0_1, 105, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Reset",515,G__Dict_228_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Dump",406,G__Dict_228_0_3, 121, -1, -1, 0, 1, 1, 1, 0, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PrintListOfObjects",1832,G__Dict_228_0_4, 121, -1, -1, 0, 1, 1, 1, 0, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("NTCollection<TopTree::NTJet>", 2596, G__Dict_228_0_5, (int) ('i'), 
G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR), -1, 0, 1, 1, 1, 0, "u 'TopTree::NTCollection<TopTree::NTJet>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~NTCollection<TopTree::NTJet>", 2722, G__Dict_228_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Dict_228_0_7, (int) ('u'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR), -1, 1, 1, 1, 1, 0, "u 'TopTree::NTCollection<TopTree::NTJet>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTopTreecLcLNTVertex(void) {
   /* TopTree::NTVertex */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTVertex));
   G__memfunc_setup("NTVertex",800,G__Dict_233_0_1, 105, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTVertex), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Reset",515,G__Dict_233_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Dump",406,G__Dict_233_0_3, 121, -1, -1, 0, 1, 1, 1, 0, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PrintP4",657,G__Dict_233_0_4, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TLorentzVector' - 0 - a u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PrintP3",656,G__Dict_233_0_5, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TVector3' - 0 - a u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNTVertex",1088,G__Dict_233_0_6, 117, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTVertex), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNTVertexPointer",1825,G__Dict_233_0_7, 85, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTVertex), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("NTVertex", 800, G__Dict_233_0_8, (int) ('i'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTVertex), -1, 0, 1, 1, 1, 0, "u 'TopTree::NTVertex' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~NTVertex", 926, G__Dict_233_0_9, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Dict_233_0_10, (int) ('u'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTVertex), -1, 1, 1, 1, 1, 0, "u 'TopTree::NTVertex' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTopTreecLcLNTTrack(void) {
   /* TopTree::NTTrack */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTrack));
   G__memfunc_setup("NTTrack",663,G__Dict_234_0_1, 105, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTrack), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Reset",515,G__Dict_234_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Dump",406,G__Dict_234_0_3, 121, -1, -1, 0, 1, 1, 1, 0, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PrintP4",657,G__Dict_234_0_4, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TLorentzVector' - 0 - a u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNTTrack",951,G__Dict_234_0_5, 117, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTrack), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNTTrackPointer",1688,G__Dict_234_0_6, 85, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTrack), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("NTTrack", 663, G__Dict_234_0_7, (int) ('i'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTrack), -1, 0, 1, 1, 1, 0, "u 'TopTree::NTTrack' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~NTTrack", 789, G__Dict_234_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Dict_234_0_9, (int) ('u'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTrack), -1, 1, 1, 1, 1, 0, "u 'TopTree::NTTrack' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTopTreecLcLWDecaysMC(void) {
   /* TopTree::WDecaysMC */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLWDecaysMC));
   G__memfunc_setup("WDecaysMC",832,G__Dict_235_0_1, 105, G__get_linked_tagnum(&G__DictLN_TopTreecLcLWDecaysMC), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("WDecaysMC", 832, G__Dict_235_0_2, (int) ('i'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLWDecaysMC), -1, 0, 1, 1, 1, 0, "u 'TopTree::WDecaysMC' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~WDecaysMC", 958, G__Dict_235_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Dict_235_0_4, (int) ('u'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLWDecaysMC), -1, 1, 1, 1, 1, 0, "u 'TopTree::WDecaysMC' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTopTreecLcLZDecaysMC(void) {
   /* TopTree::ZDecaysMC */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLZDecaysMC));
   G__memfunc_setup("ZDecaysMC",835,G__Dict_236_0_1, 105, G__get_linked_tagnum(&G__DictLN_TopTreecLcLZDecaysMC), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ZDecaysMC", 835, G__Dict_236_0_2, (int) ('i'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLZDecaysMC), -1, 0, 1, 1, 1, 0, "u 'TopTree::ZDecaysMC' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ZDecaysMC", 961, G__Dict_236_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Dict_236_0_4, (int) ('u'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLZDecaysMC), -1, 1, 1, 1, 1, 0, "u 'TopTree::ZDecaysMC' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTopTreecLcLTopDecaysMC(void) {
   /* TopTree::TopDecaysMC */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLTopDecaysMC));
   G__memfunc_setup("TopDecaysMC",1052,G__Dict_237_0_1, 105, G__get_linked_tagnum(&G__DictLN_TopTreecLcLTopDecaysMC), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TopDecaysMC", 1052, G__Dict_237_0_2, (int) ('i'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLTopDecaysMC), -1, 0, 1, 1, 1, 0, "u 'TopTree::TopDecaysMC' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TopDecaysMC", 1178, G__Dict_237_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Dict_237_0_4, (int) ('u'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLTopDecaysMC), -1, 1, 1, 1, 1, 0, "u 'TopTree::TopDecaysMC' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTopTreecLcLNTPU(void) {
   /* TopTree::NTPU */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTPU));
   G__memfunc_setup("NTPU",327,G__Dict_238_0_1, 105, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTPU), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Reset",515,G__Dict_238_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Dump",406,G__Dict_238_0_3, 121, -1, -1, 0, 1, 1, 1, 0, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNTPU",615,G__Dict_238_0_4, 117, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTPU), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNTPUPointer",1352,G__Dict_238_0_5, 85, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTPU), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("NTPU", 327, G__Dict_238_0_6, (int) ('i'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTPU), -1, 0, 1, 1, 1, 0, "u 'TopTree::NTPU' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~NTPU", 453, G__Dict_238_0_7, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Dict_238_0_8, (int) ('u'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTPU), -1, 1, 1, 1, 1, 0, "u 'TopTree::NTPU' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTopTreecLcLNTEvent(void) {
   /* TopTree::NTEvent */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTEvent));
   G__memfunc_setup("NTEvent",676,G__Dict_239_0_1, 105, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTEvent), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Reset",515,G__Dict_239_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Print",525,G__Dict_239_0_3, 121, -1, -1, 0, 1, 1, 1, 0, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PrintTriggerPassed",1857,G__Dict_239_0_4, 121, -1, -1, 0, 1, 1, 1, 0, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", "* print the list of triggers passed */", (void*) NULL, 0);
   G__memfunc_setup("PrintTriggerList",1661,G__Dict_239_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 - os", "* print the list of all triggers registered */", (void*) NULL, 0);
   G__memfunc_setup("TriggerPassed",1332,G__Dict_239_0_6, 103, -1, -1, 0, 1, 1, 1, 0, "u 'string' - 0 - trigName", "* return true if passes trigger \"trigName\"  */", (void*) NULL, 0);
   G__memfunc_setup("TriggerStored",1349,G__Dict_239_0_7, 103, -1, -1, 0, 1, 1, 1, 0, "u 'string' - 0 - trigName", "* return true if trigger \"trigName\" is stored  */", (void*) NULL, 0);
   G__memfunc_setup("NewElectron",1126,G__Dict_239_0_8, 85, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTElectron), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NewPhoton",930,G__Dict_239_0_9, 85, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTPhoton), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NewMuon",713,G__Dict_239_0_10, 85, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTMuon), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NewTauColl",990,G__Dict_239_0_11, 85, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NewVertex",936,G__Dict_239_0_12, 85, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTVertex), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NewJetMet",883,G__Dict_239_0_13, 85, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTJetMet), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NewTrack",799,G__Dict_239_0_14, 85, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTTrack), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NewPU",463,G__Dict_239_0_15, 85, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTPU), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NewElectron",1126,G__Dict_239_0_16, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TopTree::NTElectron' - 11 - electron", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NewPhoton",930,G__Dict_239_0_17, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TopTree::NTPhoton' - 11 - photon", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NewMuon",713,G__Dict_239_0_18, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TopTree::NTMuon' - 11 - muon", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NewTauColl",990,G__Dict_239_0_19, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TopTree::NTCollection<TopTree::NTTau>' - 11 - tau", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NewVertex",936,G__Dict_239_0_20, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TopTree::NTVertex' - 11 - vertex", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NewTrack",799,G__Dict_239_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TopTree::NTTrack' - 11 - track", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NewJetMet",883,G__Dict_239_0_22, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TopTree::NTJetMet' - 11 - jetmet", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NewPU",463,G__Dict_239_0_23, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TopTree::NTPU' - 11 - pileup", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("NTEvent", 676, G__Dict_239_0_24, (int) ('i'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTEvent), -1, 0, 1, 1, 1, 0, "u 'TopTree::NTEvent' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~NTEvent", 802, G__Dict_239_0_25, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTopTreecLcLNTCollectionlETopTreecLcLNTTaugR(void) {
   /* TopTree::NTCollection<TopTree::NTTau> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR));
   G__memfunc_setup("NTCollection<TopTree::NTTau>",2603,G__Dict_240_0_1, 105, G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Reset",515,G__Dict_240_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Dump",406,G__Dict_240_0_3, 121, -1, -1, 0, 1, 1, 1, 0, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PrintListOfObjects",1832,G__Dict_240_0_4, 121, -1, -1, 0, 1, 1, 1, 0, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 'std::cout' os", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("NTCollection<TopTree::NTTau>", 2603, G__Dict_240_0_5, (int) ('i'), 
G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR), -1, 0, 1, 1, 1, 0, "u 'TopTree::NTCollection<TopTree::NTTau>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~NTCollection<TopTree::NTTau>", 2729, G__Dict_240_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Dict_240_0_7, (int) ('u'), G__get_linked_tagnum(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR), -1, 1, 1, 1, 1, 0, "u 'TopTree::NTCollection<TopTree::NTTau>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEstringcOboolgR(void) {
   /* pair<string,bool> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictLN_pairlEstringcOboolgR));
   G__memfunc_setup("pair<string,bool>",1685,G__Dict_246_0_1, 105, G__get_linked_tagnum(&G__DictLN_pairlEstringcOboolgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<string,bool>",1685,G__Dict_246_0_2, 105, G__get_linked_tagnum(&G__DictLN_pairlEstringcOboolgR), -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - a g - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__DictLN_pairlEstringcOboolgR), -1, 1, 1, 1, 4, 0, "u 'pair<string,bool>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<string,bool>", 1685, G__Dict_246_0_4, (int) ('i'), G__get_linked_tagnum(&G__DictLN_pairlEstringcOboolgR), -1, 0, 1, 1, 1, 0, "u 'pair<string,bool>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<string,bool>", 1811, G__Dict_246_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncDict() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {
}

static void G__cpp_setup_global2() {

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalDict() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
  G__cpp_setup_global2();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
}

static void G__cpp_setup_func5() {
}

static void G__cpp_setup_func6() {
}

static void G__cpp_setup_func7() {
}

static void G__cpp_setup_func8() {
}

static void G__cpp_setup_func9() {
}

static void G__cpp_setup_func10() {
}

static void G__cpp_setup_func11() {
}

static void G__cpp_setup_func12() {
}

static void G__cpp_setup_func13() {
}

static void G__cpp_setup_func14() {
}

static void G__cpp_setup_func15() {
}

static void G__cpp_setup_func16() {
}

static void G__cpp_setup_func17() {
}

static void G__cpp_setup_func18() {
}

static void G__cpp_setup_func19() {
}

static void G__cpp_setup_func20() {
}

static void G__cpp_setup_func21() {
}

static void G__cpp_setup_func22() {
}

static void G__cpp_setup_func23() {
}

static void G__cpp_setup_func24() {
}

static void G__cpp_setup_func25() {

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcDict() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
  G__cpp_setup_func6();
  G__cpp_setup_func7();
  G__cpp_setup_func8();
  G__cpp_setup_func9();
  G__cpp_setup_func10();
  G__cpp_setup_func11();
  G__cpp_setup_func12();
  G__cpp_setup_func13();
  G__cpp_setup_func14();
  G__cpp_setup_func15();
  G__cpp_setup_func16();
  G__cpp_setup_func17();
  G__cpp_setup_func18();
  G__cpp_setup_func19();
  G__cpp_setup_func20();
  G__cpp_setup_func21();
  G__cpp_setup_func22();
  G__cpp_setup_func23();
  G__cpp_setup_func24();
  G__cpp_setup_func25();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__DictLN_vectorlEfloatcOallocatorlEfloatgRsPgR = { "vector<float,allocator<float> >" , 99 , -1 };
G__linked_taginfo G__DictLN_basic_ostreamlEcharcOchar_traitslEchargRsPgR = { "basic_ostream<char,char_traits<char> >" , 99 , -1 };
G__linked_taginfo G__DictLN_string = { "string" , 99 , -1 };
G__linked_taginfo G__DictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__DictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictLN_TopTree = { "TopTree" , 110 , -1 };
G__linked_taginfo G__DictLN_TMatrixTBaselEfloatgR = { "TMatrixTBase<float>" , 99 , -1 };
G__linked_taginfo G__DictLN_TMatrixTBaselEdoublegR = { "TMatrixTBase<double>" , 99 , -1 };
G__linked_taginfo G__DictLN_TVectorTlEfloatgR = { "TVectorT<float>" , 99 , -1 };
G__linked_taginfo G__DictLN_TVectorTlEdoublegR = { "TVectorT<double>" , 99 , -1 };
G__linked_taginfo G__DictLN_TElementActionTlEfloatgR = { "TElementActionT<float>" , 99 , -1 };
G__linked_taginfo G__DictLN_TElementPosActionTlEfloatgR = { "TElementPosActionT<float>" , 99 , -1 };
G__linked_taginfo G__DictLN_TMatrixTlEfloatgR = { "TMatrixT<float>" , 99 , -1 };
G__linked_taginfo G__DictLN_TMatrixTRow_constlEfloatgR = { "TMatrixTRow_const<float>" , 99 , -1 };
G__linked_taginfo G__DictLN_TMatrixTRowlEfloatgR = { "TMatrixTRow<float>" , 99 , -1 };
G__linked_taginfo G__DictLN_TMatrixTDiag_constlEfloatgR = { "TMatrixTDiag_const<float>" , 99 , -1 };
G__linked_taginfo G__DictLN_TMatrixTColumn_constlEfloatgR = { "TMatrixTColumn_const<float>" , 99 , -1 };
G__linked_taginfo G__DictLN_TMatrixTFlat_constlEfloatgR = { "TMatrixTFlat_const<float>" , 99 , -1 };
G__linked_taginfo G__DictLN_TMatrixTSub_constlEfloatgR = { "TMatrixTSub_const<float>" , 99 , -1 };
G__linked_taginfo G__DictLN_TMatrixTSparseRow_constlEfloatgR = { "TMatrixTSparseRow_const<float>" , 99 , -1 };
G__linked_taginfo G__DictLN_TMatrixTSparseDiag_constlEfloatgR = { "TMatrixTSparseDiag_const<float>" , 99 , -1 };
G__linked_taginfo G__DictLN_TMatrixTColumnlEfloatgR = { "TMatrixTColumn<float>" , 99 , -1 };
G__linked_taginfo G__DictLN_TMatrixTDiaglEfloatgR = { "TMatrixTDiag<float>" , 99 , -1 };
G__linked_taginfo G__DictLN_TMatrixTFlatlEfloatgR = { "TMatrixTFlat<float>" , 99 , -1 };
G__linked_taginfo G__DictLN_TMatrixTSublEfloatgR = { "TMatrixTSub<float>" , 99 , -1 };
G__linked_taginfo G__DictLN_TMatrixTSparseRowlEfloatgR = { "TMatrixTSparseRow<float>" , 99 , -1 };
G__linked_taginfo G__DictLN_TMatrixTSparseDiaglEfloatgR = { "TMatrixTSparseDiag<float>" , 99 , -1 };
G__linked_taginfo G__DictLN_TVector3 = { "TVector3" , 99 , -1 };
G__linked_taginfo G__DictLN_TLorentzVector = { "TLorentzVector" , 99 , -1 };
G__linked_taginfo G__DictLN_TopTreecLcLNTLepton = { "TopTree::NTLepton" , 99 , -1 };
G__linked_taginfo G__DictLN_TopTreecLcLNTElectron = { "TopTree::NTElectron" , 99 , -1 };
G__linked_taginfo G__DictLN_TopTreecLcLNTJet = { "TopTree::NTJet" , 99 , -1 };
G__linked_taginfo G__DictLN_pairlEstringcOfloatgR = { "pair<string,float>" , 115 , -1 };
G__linked_taginfo G__DictLN_vectorlEpairlEstringcOfloatgRcOallocatorlEpairlEstringcOfloatgRsPgRsPgR = { "vector<pair<string,float>,allocator<pair<string,float> > >" , 99 , -1 };
G__linked_taginfo G__DictLN_reverse_iteratorlEvectorlEpairlEstringcOfloatgRcOallocatorlEpairlEstringcOfloatgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<pair<string,float>,allocator<pair<string,float> > >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictLN_TopTreecLcLNTPhoton = { "TopTree::NTPhoton" , 99 , -1 };
G__linked_taginfo G__DictLN_TopTreecLcLNTMuon = { "TopTree::NTMuon" , 99 , -1 };
G__linked_taginfo G__DictLN_TopTreecLcLNTTau = { "TopTree::NTTau" , 99 , -1 };
G__linked_taginfo G__DictLN_TopTreecLcLNTMET = { "TopTree::NTMET" , 99 , -1 };
G__linked_taginfo G__DictLN_TopTreecLcLNTJetMet = { "TopTree::NTJetMet" , 99 , -1 };
G__linked_taginfo G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR = { "TopTree::NTCollection<TopTree::NTJet>" , 99 , -1 };
G__linked_taginfo G__DictLN_vectorlETopTreecLcLNTJetcOallocatorlETopTreecLcLNTJetgRsPgR = { "vector<TopTree::NTJet,allocator<TopTree::NTJet> >" , 99 , -1 };
G__linked_taginfo G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTJetcOallocatorlETopTreecLcLNTJetgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TopTree::NTJet,allocator<TopTree::NTJet> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictLN_TopTreecLcLNTVertex = { "TopTree::NTVertex" , 99 , -1 };
G__linked_taginfo G__DictLN_TopTreecLcLNTTrack = { "TopTree::NTTrack" , 99 , -1 };
G__linked_taginfo G__DictLN_TopTreecLcLWDecaysMC = { "TopTree::WDecaysMC" , 99 , -1 };
G__linked_taginfo G__DictLN_TopTreecLcLZDecaysMC = { "TopTree::ZDecaysMC" , 99 , -1 };
G__linked_taginfo G__DictLN_TopTreecLcLTopDecaysMC = { "TopTree::TopDecaysMC" , 99 , -1 };
G__linked_taginfo G__DictLN_TopTreecLcLNTPU = { "TopTree::NTPU" , 99 , -1 };
G__linked_taginfo G__DictLN_TopTreecLcLNTEvent = { "TopTree::NTEvent" , 99 , -1 };
G__linked_taginfo G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR = { "TopTree::NTCollection<TopTree::NTTau>" , 99 , -1 };
G__linked_taginfo G__DictLN_vectorlETopTreecLcLNTTaucOallocatorlETopTreecLcLNTTaugRsPgR = { "vector<TopTree::NTTau,allocator<TopTree::NTTau> >" , 99 , -1 };
G__linked_taginfo G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTTaucOallocatorlETopTreecLcLNTTaugRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TopTree::NTTau,allocator<TopTree::NTTau> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictLN_pairlEintcOintgR = { "pair<int,int>" , 115 , -1 };
G__linked_taginfo G__DictLN_pairlEstringcOboolgR = { "pair<string,bool>" , 115 , -1 };
G__linked_taginfo G__DictLN_vectorlEpairlEstringcOboolgRcOallocatorlEpairlEstringcOboolgRsPgRsPgR = { "vector<pair<string,bool>,allocator<pair<string,bool> > >" , 99 , -1 };
G__linked_taginfo G__DictLN_reverse_iteratorlEvectorlEpairlEstringcOboolgRcOallocatorlEpairlEstringcOboolgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<pair<string,bool>,allocator<pair<string,bool> > >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictLN_pairlEstringcOintgR = { "pair<string,int>" , 115 , -1 };
G__linked_taginfo G__DictLN_vectorlEpairlEstringcOintgRcOallocatorlEpairlEstringcOintgRsPgRsPgR = { "vector<pair<string,int>,allocator<pair<string,int> > >" , 99 , -1 };
G__linked_taginfo G__DictLN_reverse_iteratorlEvectorlEpairlEstringcOintgRcOallocatorlEpairlEstringcOintgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<pair<string,int>,allocator<pair<string,int> > >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictLN_vectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgR = { "vector<TLorentzVector,allocator<TLorentzVector> >" , 99 , -1 };
G__linked_taginfo G__DictLN_reverse_iteratorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TLorentzVector,allocator<TLorentzVector> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictLN_vectorlETopTreecLcLNTVertexcOallocatorlETopTreecLcLNTVertexgRsPgR = { "vector<TopTree::NTVertex,allocator<TopTree::NTVertex> >" , 99 , -1 };
G__linked_taginfo G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTVertexcOallocatorlETopTreecLcLNTVertexgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TopTree::NTVertex,allocator<TopTree::NTVertex> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictLN_vectorlETopTreecLcLNTPUcOallocatorlETopTreecLcLNTPUgRsPgR = { "vector<TopTree::NTPU,allocator<TopTree::NTPU> >" , 99 , -1 };
G__linked_taginfo G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTPUcOallocatorlETopTreecLcLNTPUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TopTree::NTPU,allocator<TopTree::NTPU> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictLN_vectorlETopTreecLcLNTJetMetcOallocatorlETopTreecLcLNTJetMetgRsPgR = { "vector<TopTree::NTJetMet,allocator<TopTree::NTJetMet> >" , 99 , -1 };
G__linked_taginfo G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTJetMetcOallocatorlETopTreecLcLNTJetMetgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TopTree::NTJetMet,allocator<TopTree::NTJetMet> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictLN_vectorlETopTreecLcLNTElectroncOallocatorlETopTreecLcLNTElectrongRsPgR = { "vector<TopTree::NTElectron,allocator<TopTree::NTElectron> >" , 99 , -1 };
G__linked_taginfo G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTElectroncOallocatorlETopTreecLcLNTElectrongRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TopTree::NTElectron,allocator<TopTree::NTElectron> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictLN_vectorlETopTreecLcLNTMuoncOallocatorlETopTreecLcLNTMuongRsPgR = { "vector<TopTree::NTMuon,allocator<TopTree::NTMuon> >" , 99 , -1 };
G__linked_taginfo G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTMuoncOallocatorlETopTreecLcLNTMuongRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TopTree::NTMuon,allocator<TopTree::NTMuon> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictLN_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRcOallocatorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgRsPgR = { "vector<TopTree::NTCollection<TopTree::NTTau>,allocator<TopTree::NTCollection<TopTree::NTTau> > >" , 99 , -1 };
G__linked_taginfo G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRcOallocatorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TopTree::NTCollection<TopTree::NTTau>,allocator<TopTree::NTCollection<TopTree::NTTau> > >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictLN_vectorlETopTreecLcLNTPhotoncOallocatorlETopTreecLcLNTPhotongRsPgR = { "vector<TopTree::NTPhoton,allocator<TopTree::NTPhoton> >" , 99 , -1 };
G__linked_taginfo G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTPhotoncOallocatorlETopTreecLcLNTPhotongRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TopTree::NTPhoton,allocator<TopTree::NTPhoton> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictLN_vectorlETopTreecLcLNTTrackcOallocatorlETopTreecLcLNTTrackgRsPgR = { "vector<TopTree::NTTrack,allocator<TopTree::NTTrack> >" , 99 , -1 };
G__linked_taginfo G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTTrackcOallocatorlETopTreecLcLNTTrackgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TopTree::NTTrack,allocator<TopTree::NTTrack> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictLN_vectorlETopTreecLcLWDecaysMCcOallocatorlETopTreecLcLWDecaysMCgRsPgR = { "vector<TopTree::WDecaysMC,allocator<TopTree::WDecaysMC> >" , 99 , -1 };
G__linked_taginfo G__DictLN_reverse_iteratorlEvectorlETopTreecLcLWDecaysMCcOallocatorlETopTreecLcLWDecaysMCgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TopTree::WDecaysMC,allocator<TopTree::WDecaysMC> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictLN_vectorlETopTreecLcLZDecaysMCcOallocatorlETopTreecLcLZDecaysMCgRsPgR = { "vector<TopTree::ZDecaysMC,allocator<TopTree::ZDecaysMC> >" , 99 , -1 };
G__linked_taginfo G__DictLN_reverse_iteratorlEvectorlETopTreecLcLZDecaysMCcOallocatorlETopTreecLcLZDecaysMCgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TopTree::ZDecaysMC,allocator<TopTree::ZDecaysMC> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictLN_vectorlETopTreecLcLTopDecaysMCcOallocatorlETopTreecLcLTopDecaysMCgRsPgR = { "vector<TopTree::TopDecaysMC,allocator<TopTree::TopDecaysMC> >" , 99 , -1 };
G__linked_taginfo G__DictLN_reverse_iteratorlEvectorlETopTreecLcLTopDecaysMCcOallocatorlETopTreecLcLTopDecaysMCgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TopTree::TopDecaysMC,allocator<TopTree::TopDecaysMC> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictLN_vectorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcOallocatorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRsPgRsPgR = { "vector<vector<TLorentzVector,allocator<TLorentzVector> >,allocator<vector<TLorentzVector,allocator<TLorentzVector> > > >" , 99 , -1 };
G__linked_taginfo G__DictLN_reverse_iteratorlEvectorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcOallocatorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<vector<TLorentzVector,allocator<TLorentzVector> >,allocator<vector<TLorentzVector,allocator<TLorentzVector> > > >::iterator>" , 99 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtableDict() {
  G__DictLN_vectorlEfloatcOallocatorlEfloatgRsPgR.tagnum = -1 ;
  G__DictLN_basic_ostreamlEcharcOchar_traitslEchargRsPgR.tagnum = -1 ;
  G__DictLN_string.tagnum = -1 ;
  G__DictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__DictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictLN_TopTree.tagnum = -1 ;
  G__DictLN_TMatrixTBaselEfloatgR.tagnum = -1 ;
  G__DictLN_TMatrixTBaselEdoublegR.tagnum = -1 ;
  G__DictLN_TVectorTlEfloatgR.tagnum = -1 ;
  G__DictLN_TVectorTlEdoublegR.tagnum = -1 ;
  G__DictLN_TElementActionTlEfloatgR.tagnum = -1 ;
  G__DictLN_TElementPosActionTlEfloatgR.tagnum = -1 ;
  G__DictLN_TMatrixTlEfloatgR.tagnum = -1 ;
  G__DictLN_TMatrixTRow_constlEfloatgR.tagnum = -1 ;
  G__DictLN_TMatrixTRowlEfloatgR.tagnum = -1 ;
  G__DictLN_TMatrixTDiag_constlEfloatgR.tagnum = -1 ;
  G__DictLN_TMatrixTColumn_constlEfloatgR.tagnum = -1 ;
  G__DictLN_TMatrixTFlat_constlEfloatgR.tagnum = -1 ;
  G__DictLN_TMatrixTSub_constlEfloatgR.tagnum = -1 ;
  G__DictLN_TMatrixTSparseRow_constlEfloatgR.tagnum = -1 ;
  G__DictLN_TMatrixTSparseDiag_constlEfloatgR.tagnum = -1 ;
  G__DictLN_TMatrixTColumnlEfloatgR.tagnum = -1 ;
  G__DictLN_TMatrixTDiaglEfloatgR.tagnum = -1 ;
  G__DictLN_TMatrixTFlatlEfloatgR.tagnum = -1 ;
  G__DictLN_TMatrixTSublEfloatgR.tagnum = -1 ;
  G__DictLN_TMatrixTSparseRowlEfloatgR.tagnum = -1 ;
  G__DictLN_TMatrixTSparseDiaglEfloatgR.tagnum = -1 ;
  G__DictLN_TVector3.tagnum = -1 ;
  G__DictLN_TLorentzVector.tagnum = -1 ;
  G__DictLN_TopTreecLcLNTLepton.tagnum = -1 ;
  G__DictLN_TopTreecLcLNTElectron.tagnum = -1 ;
  G__DictLN_TopTreecLcLNTJet.tagnum = -1 ;
  G__DictLN_pairlEstringcOfloatgR.tagnum = -1 ;
  G__DictLN_vectorlEpairlEstringcOfloatgRcOallocatorlEpairlEstringcOfloatgRsPgRsPgR.tagnum = -1 ;
  G__DictLN_reverse_iteratorlEvectorlEpairlEstringcOfloatgRcOallocatorlEpairlEstringcOfloatgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictLN_TopTreecLcLNTPhoton.tagnum = -1 ;
  G__DictLN_TopTreecLcLNTMuon.tagnum = -1 ;
  G__DictLN_TopTreecLcLNTTau.tagnum = -1 ;
  G__DictLN_TopTreecLcLNTMET.tagnum = -1 ;
  G__DictLN_TopTreecLcLNTJetMet.tagnum = -1 ;
  G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR.tagnum = -1 ;
  G__DictLN_vectorlETopTreecLcLNTJetcOallocatorlETopTreecLcLNTJetgRsPgR.tagnum = -1 ;
  G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTJetcOallocatorlETopTreecLcLNTJetgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictLN_TopTreecLcLNTVertex.tagnum = -1 ;
  G__DictLN_TopTreecLcLNTTrack.tagnum = -1 ;
  G__DictLN_TopTreecLcLWDecaysMC.tagnum = -1 ;
  G__DictLN_TopTreecLcLZDecaysMC.tagnum = -1 ;
  G__DictLN_TopTreecLcLTopDecaysMC.tagnum = -1 ;
  G__DictLN_TopTreecLcLNTPU.tagnum = -1 ;
  G__DictLN_TopTreecLcLNTEvent.tagnum = -1 ;
  G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR.tagnum = -1 ;
  G__DictLN_vectorlETopTreecLcLNTTaucOallocatorlETopTreecLcLNTTaugRsPgR.tagnum = -1 ;
  G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTTaucOallocatorlETopTreecLcLNTTaugRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictLN_pairlEintcOintgR.tagnum = -1 ;
  G__DictLN_pairlEstringcOboolgR.tagnum = -1 ;
  G__DictLN_vectorlEpairlEstringcOboolgRcOallocatorlEpairlEstringcOboolgRsPgRsPgR.tagnum = -1 ;
  G__DictLN_reverse_iteratorlEvectorlEpairlEstringcOboolgRcOallocatorlEpairlEstringcOboolgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictLN_pairlEstringcOintgR.tagnum = -1 ;
  G__DictLN_vectorlEpairlEstringcOintgRcOallocatorlEpairlEstringcOintgRsPgRsPgR.tagnum = -1 ;
  G__DictLN_reverse_iteratorlEvectorlEpairlEstringcOintgRcOallocatorlEpairlEstringcOintgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictLN_vectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgR.tagnum = -1 ;
  G__DictLN_reverse_iteratorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictLN_vectorlETopTreecLcLNTVertexcOallocatorlETopTreecLcLNTVertexgRsPgR.tagnum = -1 ;
  G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTVertexcOallocatorlETopTreecLcLNTVertexgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictLN_vectorlETopTreecLcLNTPUcOallocatorlETopTreecLcLNTPUgRsPgR.tagnum = -1 ;
  G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTPUcOallocatorlETopTreecLcLNTPUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictLN_vectorlETopTreecLcLNTJetMetcOallocatorlETopTreecLcLNTJetMetgRsPgR.tagnum = -1 ;
  G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTJetMetcOallocatorlETopTreecLcLNTJetMetgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictLN_vectorlETopTreecLcLNTElectroncOallocatorlETopTreecLcLNTElectrongRsPgR.tagnum = -1 ;
  G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTElectroncOallocatorlETopTreecLcLNTElectrongRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictLN_vectorlETopTreecLcLNTMuoncOallocatorlETopTreecLcLNTMuongRsPgR.tagnum = -1 ;
  G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTMuoncOallocatorlETopTreecLcLNTMuongRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictLN_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRcOallocatorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgRsPgR.tagnum = -1 ;
  G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRcOallocatorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictLN_vectorlETopTreecLcLNTPhotoncOallocatorlETopTreecLcLNTPhotongRsPgR.tagnum = -1 ;
  G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTPhotoncOallocatorlETopTreecLcLNTPhotongRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictLN_vectorlETopTreecLcLNTTrackcOallocatorlETopTreecLcLNTTrackgRsPgR.tagnum = -1 ;
  G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTTrackcOallocatorlETopTreecLcLNTTrackgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictLN_vectorlETopTreecLcLWDecaysMCcOallocatorlETopTreecLcLWDecaysMCgRsPgR.tagnum = -1 ;
  G__DictLN_reverse_iteratorlEvectorlETopTreecLcLWDecaysMCcOallocatorlETopTreecLcLWDecaysMCgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictLN_vectorlETopTreecLcLZDecaysMCcOallocatorlETopTreecLcLZDecaysMCgRsPgR.tagnum = -1 ;
  G__DictLN_reverse_iteratorlEvectorlETopTreecLcLZDecaysMCcOallocatorlETopTreecLcLZDecaysMCgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictLN_vectorlETopTreecLcLTopDecaysMCcOallocatorlETopTreecLcLTopDecaysMCgRsPgR.tagnum = -1 ;
  G__DictLN_reverse_iteratorlEvectorlETopTreecLcLTopDecaysMCcOallocatorlETopTreecLcLTopDecaysMCgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictLN_vectorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcOallocatorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRsPgRsPgR.tagnum = -1 ;
  G__DictLN_reverse_iteratorlEvectorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcOallocatorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtableDict() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__DictLN_vectorlEfloatcOallocatorlEfloatgRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_basic_ostreamlEcharcOchar_traitslEchargRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_string);
   G__get_linked_tagnum_fwd(&G__DictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictLN_TopTree);
   G__get_linked_tagnum_fwd(&G__DictLN_TMatrixTBaselEfloatgR);
   G__get_linked_tagnum_fwd(&G__DictLN_TMatrixTBaselEdoublegR);
   G__get_linked_tagnum_fwd(&G__DictLN_TVectorTlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DictLN_TVectorTlEdoublegR);
   G__get_linked_tagnum_fwd(&G__DictLN_TElementActionTlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DictLN_TElementPosActionTlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DictLN_TMatrixTlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DictLN_TMatrixTRow_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DictLN_TMatrixTRowlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DictLN_TMatrixTDiag_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DictLN_TMatrixTColumn_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DictLN_TMatrixTFlat_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DictLN_TMatrixTSub_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DictLN_TMatrixTSparseRow_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DictLN_TMatrixTSparseDiag_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DictLN_TMatrixTColumnlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DictLN_TMatrixTDiaglEfloatgR);
   G__get_linked_tagnum_fwd(&G__DictLN_TMatrixTFlatlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DictLN_TMatrixTSublEfloatgR);
   G__get_linked_tagnum_fwd(&G__DictLN_TMatrixTSparseRowlEfloatgR);
   G__get_linked_tagnum_fwd(&G__DictLN_TMatrixTSparseDiaglEfloatgR);
   G__get_linked_tagnum_fwd(&G__DictLN_TVector3);
   G__get_linked_tagnum_fwd(&G__DictLN_TLorentzVector);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictLN_TopTreecLcLNTLepton),sizeof(TopTree::NTLepton),-1,263424,(char*)NULL,G__setup_memvarTopTreecLcLNTLepton,G__setup_memfuncTopTreecLcLNTLepton);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictLN_TopTreecLcLNTElectron),sizeof(TopTree::NTElectron),-1,263424,(char*)NULL,G__setup_memvarTopTreecLcLNTElectron,G__setup_memfuncTopTreecLcLNTElectron);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictLN_TopTreecLcLNTJet),sizeof(TopTree::NTJet),-1,263424,(char*)NULL,G__setup_memvarTopTreecLcLNTJet,G__setup_memfuncTopTreecLcLNTJet);
   G__get_linked_tagnum_fwd(&G__DictLN_pairlEstringcOfloatgR);
   G__get_linked_tagnum_fwd(&G__DictLN_vectorlEpairlEstringcOfloatgRcOallocatorlEpairlEstringcOfloatgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_reverse_iteratorlEvectorlEpairlEstringcOfloatgRcOallocatorlEpairlEstringcOfloatgRsPgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictLN_TopTreecLcLNTPhoton),sizeof(TopTree::NTPhoton),-1,263424,(char*)NULL,G__setup_memvarTopTreecLcLNTPhoton,G__setup_memfuncTopTreecLcLNTPhoton);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictLN_TopTreecLcLNTMuon),sizeof(TopTree::NTMuon),-1,263424,(char*)NULL,G__setup_memvarTopTreecLcLNTMuon,G__setup_memfuncTopTreecLcLNTMuon);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictLN_TopTreecLcLNTTau),sizeof(TopTree::NTTau),-1,263424,(char*)NULL,G__setup_memvarTopTreecLcLNTTau,G__setup_memfuncTopTreecLcLNTTau);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictLN_TopTreecLcLNTMET),sizeof(TopTree::NTMET),-1,263424,(char*)NULL,G__setup_memvarTopTreecLcLNTMET,G__setup_memfuncTopTreecLcLNTMET);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictLN_TopTreecLcLNTJetMet),sizeof(TopTree::NTJetMet),-1,263424,(char*)NULL,G__setup_memvarTopTreecLcLNTJetMet,G__setup_memfuncTopTreecLcLNTJetMet);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTJetgR),sizeof(TopTree::NTCollection<TopTree::NTJet>),-1,263424,(char*)NULL,G__setup_memvarTopTreecLcLNTCollectionlETopTreecLcLNTJetgR,G__setup_memfuncTopTreecLcLNTCollectionlETopTreecLcLNTJetgR);
   G__get_linked_tagnum_fwd(&G__DictLN_vectorlETopTreecLcLNTJetcOallocatorlETopTreecLcLNTJetgRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTJetcOallocatorlETopTreecLcLNTJetgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictLN_TopTreecLcLNTVertex),sizeof(TopTree::NTVertex),-1,263424,(char*)NULL,G__setup_memvarTopTreecLcLNTVertex,G__setup_memfuncTopTreecLcLNTVertex);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictLN_TopTreecLcLNTTrack),sizeof(TopTree::NTTrack),-1,263424,(char*)NULL,G__setup_memvarTopTreecLcLNTTrack,G__setup_memfuncTopTreecLcLNTTrack);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictLN_TopTreecLcLWDecaysMC),sizeof(TopTree::WDecaysMC),-1,263424,(char*)NULL,G__setup_memvarTopTreecLcLWDecaysMC,G__setup_memfuncTopTreecLcLWDecaysMC);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictLN_TopTreecLcLZDecaysMC),sizeof(TopTree::ZDecaysMC),-1,263424,(char*)NULL,G__setup_memvarTopTreecLcLZDecaysMC,G__setup_memfuncTopTreecLcLZDecaysMC);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictLN_TopTreecLcLTopDecaysMC),sizeof(TopTree::TopDecaysMC),-1,263424,(char*)NULL,G__setup_memvarTopTreecLcLTopDecaysMC,G__setup_memfuncTopTreecLcLTopDecaysMC);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictLN_TopTreecLcLNTPU),sizeof(TopTree::NTPU),-1,263424,(char*)NULL,G__setup_memvarTopTreecLcLNTPU,G__setup_memfuncTopTreecLcLNTPU);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictLN_TopTreecLcLNTEvent),sizeof(TopTree::NTEvent),-1,263424,(char*)NULL,G__setup_memvarTopTreecLcLNTEvent,G__setup_memfuncTopTreecLcLNTEvent);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictLN_TopTreecLcLNTCollectionlETopTreecLcLNTTaugR),sizeof(TopTree::NTCollection<TopTree::NTTau>),-1,263424,(char*)NULL,G__setup_memvarTopTreecLcLNTCollectionlETopTreecLcLNTTaugR,G__setup_memfuncTopTreecLcLNTCollectionlETopTreecLcLNTTaugR);
   G__get_linked_tagnum_fwd(&G__DictLN_vectorlETopTreecLcLNTTaucOallocatorlETopTreecLcLNTTaugRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTTaucOallocatorlETopTreecLcLNTTaugRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictLN_pairlEintcOintgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictLN_pairlEstringcOboolgR),sizeof(pair<string,bool>),-1,297216,(char*)NULL,G__setup_memvarpairlEstringcOboolgR,G__setup_memfuncpairlEstringcOboolgR);
   G__get_linked_tagnum_fwd(&G__DictLN_vectorlEpairlEstringcOboolgRcOallocatorlEpairlEstringcOboolgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_reverse_iteratorlEvectorlEpairlEstringcOboolgRcOallocatorlEpairlEstringcOboolgRsPgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictLN_pairlEstringcOintgR);
   G__get_linked_tagnum_fwd(&G__DictLN_vectorlEpairlEstringcOintgRcOallocatorlEpairlEstringcOintgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_reverse_iteratorlEvectorlEpairlEstringcOintgRcOallocatorlEpairlEstringcOintgRsPgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictLN_vectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_reverse_iteratorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictLN_vectorlETopTreecLcLNTVertexcOallocatorlETopTreecLcLNTVertexgRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTVertexcOallocatorlETopTreecLcLNTVertexgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictLN_vectorlETopTreecLcLNTPUcOallocatorlETopTreecLcLNTPUgRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTPUcOallocatorlETopTreecLcLNTPUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictLN_vectorlETopTreecLcLNTJetMetcOallocatorlETopTreecLcLNTJetMetgRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTJetMetcOallocatorlETopTreecLcLNTJetMetgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictLN_vectorlETopTreecLcLNTElectroncOallocatorlETopTreecLcLNTElectrongRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTElectroncOallocatorlETopTreecLcLNTElectrongRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictLN_vectorlETopTreecLcLNTMuoncOallocatorlETopTreecLcLNTMuongRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTMuoncOallocatorlETopTreecLcLNTMuongRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictLN_vectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRcOallocatorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRcOallocatorlETopTreecLcLNTCollectionlETopTreecLcLNTTaugRsPgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictLN_vectorlETopTreecLcLNTPhotoncOallocatorlETopTreecLcLNTPhotongRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTPhotoncOallocatorlETopTreecLcLNTPhotongRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictLN_vectorlETopTreecLcLNTTrackcOallocatorlETopTreecLcLNTTrackgRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLNTTrackcOallocatorlETopTreecLcLNTTrackgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictLN_vectorlETopTreecLcLWDecaysMCcOallocatorlETopTreecLcLWDecaysMCgRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLWDecaysMCcOallocatorlETopTreecLcLWDecaysMCgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictLN_vectorlETopTreecLcLZDecaysMCcOallocatorlETopTreecLcLZDecaysMCgRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLZDecaysMCcOallocatorlETopTreecLcLZDecaysMCgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictLN_vectorlETopTreecLcLTopDecaysMCcOallocatorlETopTreecLcLTopDecaysMCgRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_reverse_iteratorlEvectorlETopTreecLcLTopDecaysMCcOallocatorlETopTreecLcLTopDecaysMCgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictLN_vectorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcOallocatorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__DictLN_reverse_iteratorlEvectorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRcOallocatorlEvectorlETLorentzVectorcOallocatorlETLorentzVectorgRsPgRsPgRsPgRcLcLiteratorgR);
}
extern "C" void G__cpp_setupDict(void) {
  G__check_setup_version(30051515,"G__cpp_setupDict()");
  G__set_cpp_environmentDict();
  G__cpp_setup_tagtableDict();

  G__cpp_setup_inheritanceDict();

  G__cpp_setup_typetableDict();

  G__cpp_setup_memvarDict();

  G__cpp_setup_memfuncDict();
  G__cpp_setup_globalDict();
  G__cpp_setup_funcDict();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncDict();
  return;
}
class G__cpp_setup_initDict {
  public:
    G__cpp_setup_initDict() { G__add_setup_func("Dict",(G__incsetup)(&G__cpp_setupDict)); G__call_setup_funcs(); }
   ~G__cpp_setup_initDict() { G__remove_setup_func("Dict"); }
};
G__cpp_setup_initDict G__cpp_setup_initializerDict;

